# 操作系统

!!! Abstract
    
    **授课教师**：寿黎但


用户程序对内存的视图和内核程序对内存的视图**不一样**。那我们在系统调用时，我们如何规划一块内存存放参数，内核又如何知道到哪里去访问参数呢？

??? Success

    我们一般有三种方法

## Intro


### 系统调用(System Call)的类型

- Process Control

- File Management

- Device Management

- Information Maintenance

- Communications

- Protections

### 系统程序(System Programs)

??? Note "系统调用和系统程序的区别"


## OS Structures

## 进程 Process

### 1. 进程概念 (Process Concept)

* **定义**：进程是<u>“一个正在执行中的程序”</u>。操作系统执行各种程序，例如批处理系统中的“作业”（jobs）或时间共享系统中的“用户程序”或“任务”（tasks）。

* **进程的内存结构**：一个进程在内存中包含：
    * **文本区域 (text section)**：即代码 (code)；
    * **程序计数器 (program counter)**；
    * **栈 (stack)**：用于存放函数参数、局部变量和返回地址；
    * **数据区域 (data section)**：存放全局变量；
    * **堆 (heap)**：用于动态分配内存。
<center>
    <img src="images/OS/process.png" alt="Process in Memory" style="zoom 50%"/>
</center>

### 2. 进程状态 (Process State)

进程在其执行过程中会改变状态。

* **new (新建)**：进程正在被创建；
* **running (运行)**：指令正在被执行；
* **waiting (等待)**：进程正在等待某个事件发生（例如I/O完成）；
* **ready (就绪)**：进程等待被分配到处理器；
* **terminated (终止)**：进程已完成执行.

<center>
    <img src="images/OS/state_diagram.png" alt="State Changes" style="zoom 50%"/>
</center>

### 3. 进程控制块 (PCB)

* **定义**：PCB是与每个进程相关联的信息集合。
* **包含信息**：
    * 进程状态
    * 程序计数器
    * CPU寄存器内容
    * CPU调度信息
    * 内存管理信息
    * 记账信息
    * I/O状态信息
* **上下文切换 (Context Switch)**：当CPU切换到另一个进程时，系统必须保存旧进程的状态（到PCB）并加载新进程的保存状态。这个过程是开销，因为系统在切换时不做有用功。

### 4. 进程调度 (Process Scheduling)

这部分介绍了操作系统如何管理和调度进程。

* **调度队列 (Queues)**：
    * **作业队列 (Job queue)**：系统中所有的进程集合。
    * **就绪队列 (Ready queue)**：所有在主存中、准备好并等待执行的进程集合。
    * **设备队列 (Device queues)**：等待I/O设备的进程集合。
    * 进程会在这些队列之间迁移。
* **调度程序 (Schedulers)**：
    * **长期调度程序 (Long-term scheduler)**：也称“作业调度程序”，它选择哪些进程应被带入内存（就绪队列）。它控制着多道程序的程度，并且调用频率很低（秒或分钟）。
    * **短期调度程序 (Short-term scheduler)**：也称“CPU调度程序”，它选择下一个应该执行的进程并分配CPU。它的调用频率非常高（毫秒级），必须很快。
    * PPT提到，UNIX和Windows不使用长期调度程序。
    * 还提到了**中期调度 (Medium Term Scheduling)**，涉及将进程换出内存。
* **进程类型**：
    * **I/O密集型 (I/O-bound)**：花费更多时间进行I/O，有许多短暂的CPU爆发。
    * **CPU密集型 (CPU-bound)**：花费更多时间进行计算，有少数很长的CPU爆发。

### 5. 进程操作 (Operations on Processes)

这部分讨论了进程的创建和终止。

* **进程创建 (Process Creation)**：
    * 父进程创建子进程，形成一个进程树。
    * **资源共享**：父子进程可以共享所有资源、部分资源 或不共享资源。
    * **执行**：父子进程可以并发执行，或者父进程等待子进程终止。
    * **UNIX 示例**：`fork()` 系统调用用于创建新进程。`exec()` 系统调用通常在 `fork()` 之后使用，用一个新程序替换进程的内存空间。PPT中提供了一个C语言示例代码。
* **进程终止 (Process Termination)**：
    * 进程执行最后一条语句并请求操作系统删除它（例如调用 `exit`）。
    * 父进程可以终止子进程的执行（例如调用 `abort`），原因可能包括子进程超出了分配的资源 或分配给子进程的任务不再需要。
    * **级联终止 (Cascading termination)**：如果父进程退出，其所有子进程也可能被终止。
    * 在某些系统中，子进程可能成为“孤儿”进程，并被“init”进程（PID=1）收养。PPT指出在MacOS上，这个进程被称为 `launchd`。

### 6. 协作进程 (Cooperating Processes)

* **独立进程**不受其他进程影响，而**协作进程**可以影响或被其他进程影响。
* **协作的优势**：信息共享、计算加速（多CPU）、模块化 和方便性。
* **生产者-消费者问题 (Producer-Consumer Problem)**：
    * 这是一个协作进程的范例。生产者进程生产信息，消费者进程消费信息。
    * **有界缓冲区 (bounded-buffer)** 假定缓冲区大小固定。PPT提供了使用共享内存解决有界缓冲区问题的伪代码 。

### 7. 进程间通信 (Interprocess Communication, IPC)

这部分介绍了进程间通信和同步的机制。

* **两种模型**：
    * **共享内存 (Shared memory)**
    * **消息传递 (Message passing)**
* **消息传递**：
    * 提供 `send(message)` 和 `receive(message)` 操作。
    * **直接通信**：进程必须显式地命名对方（例如 `send(P, ...)`）。
    * **间接通信**：消息被发送到“邮箱”（mailboxes）或“端口”（ports）。进程通过共享邮箱进行通信。
* **同步 (Synchronization)**：
    * 消息传递可以是**阻塞的（同步）** 或**非阻塞的（异步）**。
    * `阻塞发送`：发送方被阻塞，直到消息被接收。
    * `阻塞接收`：接收方被阻塞，直到有消息可用。
* **缓冲 (Buffering)**：
    * 通信链接上的消息队列可以有**零容量**、**有界容量** 或**无限容量**。

### 8. 客户端-服务器系统中的通信

这部分介绍了几种用于客户-服务器模型的IPC机制。

* **套接字 (Sockets)**：
    * 定义为通信的“端点”（endpoint）。
    * 是IP地址和端口号的组合（例如 `161.25.19.8:1625`）。
    * 通信在**一对套接字**之间进行。
* **远程过程调用 (Remote Procedure Calls, RPC)**：
    * 它抽象了网络系统中进程之间的过程调用。
    * 使用**存根 (Stubs)** 作为服务器上实际过程的客户端代理。
    * 客户端存根定位服务器并**编组 (marshals)** 参数。服务器端存根接收消息，**解组 (unpacks)** 参数，并执行过程。
* **远程方法调用 (Remote Method Invocation, RMI)**：
    * 这是Java中类似RPC的机制。
    * 它允许一台机器上的Java程序调用一个**远程对象**上的方法。


## 线程 Thread

文档以一个Web浏览器的开发为例，说明了为什么需要线程 。

* **单线程的问题：** 如果程序采用简单的循环（检索数据、显示数据、获取输入），每个步骤都会阻塞，导致程序响应缓慢 。
* **初步尝试的缺陷：** 尝试将任务分解成非常小的片段  或在循环中不断检查是否有任务要做 ，这样做虽然能略微提高响应速度，但效率极低 。
* **核心冲突：** 程序既需要高**响应速度**（要求任务分解得极细），又需要高**效率**（要求执行大块代码），这两者是相互冲突的 。
* **线程解决方案：** 多线程允许程序创建多个并行的执行流（例如，一个线程负责检索数据，一个负责显示，一个负责获取输入）。操作系统（OS）会负责这些线程的调度 ，从而同时解决了响应速度和效率的问题。

### 线程的优势与概念

- 优势 
    * **响应速度 (Responsiveness):** 允许交互式应用程序即便在执行阻塞任务时也能继续响应用户 。
    * **资源共享 (Resource Sharing):** 线程默认共享进程的代码、数据和文件 。
    * **经济性 (Economy):** 创建和切换线程的开销远低于进程 。
    * **利用多处理器架构 (Utilization of MP Architectures):** 在多核系统上，多线程可以实现真正的并行执行，提高并发性 。

- 关键概念
    * **单线程 vs. 多线程进程：** 单线程进程只有一个执行流（一套寄存器和堆栈）；多线程进程共享代码、数据和文件，但每个线程拥有自己独立的寄存器和堆栈 。
    * **并发 vs. 并行：** **并发 (Concurrency)** 是指多个任务在单核上交错执行（看起来像同时运行）。**并行 (Parallelism)** 是指多个任务在多核上真正同时执行 。
    * **用户线程 vs. 内核线程：** **用户线程**由用户空间的线程库管理 （例如 Pthreads, Win32, Java 线程 ）。**内核线程**由操作系统内核直接支持和管理 （例如 Windows, Linux, Solaris ）。

### 多线程模型 

多线程模型定义了用户线程和内核线程之间的关系。

* **多对一模型 (Many-to-One):** 
    * **描述:** 多个用户线程映射到一个内核线程 。线程管理在用户空间完成，效率高 。
    * **缺点:** 如果一个用户线程执行了阻塞的系统调用，整个进程都会被阻塞 。内核一次只能调度一个线程 。
    * **示例:** Solaris Green Threads , GNU Portable Threads 。

* **一对一模型 (One-to-One):** 
    * **描述:** 每个用户线程映射到一个内核线程 。
    * **优点:** 提供了更好的并发性，一个线程阻塞不会影响其他线程 。
    * **缺点:** 创建每个用户线程都需要创建一个内核线程，开销较大 。
    * **示例:** Windows , Linux , Solaris 9 及更高版本 。

* **多对多模型 (Many-to-Many):** 
    * **描述:** 多个用户线程映射到多个（或更少的）内核线程 。
    * **优点:** 非常灵活 。允许程序创建任意多的用户线程，而内核线程的数量可以由操作系统动态调整 。
    * **示例:** Solaris 9 以前的版本 , Go 语言的 Goroutines 。

* **二级模型 (Two-level Model):** 
    * **描述:** 类似于多对多模型，但增加了允许将某个用户线程“绑定”到特定内核线程的功能 。
    * **示例:** Solaris 8 及更早版本 。

### 线程问题 

在使用线程时需要解决几个关键问题：

* **`fork()` 和 `exec()` 的语义:** 当多线程进程中的某个线程调用 `fork()` 时，是复制所有线程，还是只复制调用 `fork()` 的那个线程？ （`exec()` 会替换整个进程）。
* **信号处理 (Signal Handling):** 在 UNIX 系统中，当一个事件（信号）发生时 ，应该将其传递给哪个线程？（例如，传递给应用信号的线程、进程中的所有线程、某些特定线程，或指定一个线程接收所有信号）。
* **线程取消 (Thread Cancellation):** 如何提前终止一个线程 。
    * **异步取消 (Asynchronous):** 立即终止目标线程 。
    * **延迟取消 (Deferred):** 目标线程周期性地检查一个标志位，以决定是否应该自行终止 。
* **线程池 (Thread Pools):** 预先创建一定数量的线程 。当需要执行任务时，从池中获取一个可用线程，而不是创建新线程 。这可以限制线程总数 ，且服务请求更快 。
* **线程特定数据 (Thread-Specific Data):** 允许每个线程拥有自己私有的数据副本（也称线程本地存储, TLS）。这在无法控制线程创建过程（如使用线程池）时很有用 。
* **调度程序激活 (Scheduler Activations):** 在多对多或二级模型中，内核需要一种机制（称为“上调” (upcalls)）来通知用户级线程库内核线程的分配情况 ，例如当一个线程即将阻塞时通知库 。


### 具体实现

* **Pthreads:**  一个 POSIX 标准 (IEEE 1003.1c) API，用于线程创建和同步 。它只定义了行为规范，具体实现可以是用户级的，也可以是内核级的 。
* **Windows XP 线程:**  采用一对一模型 。每个线程包含线程ID、寄存器集、用户和内核堆栈以及私有存储区 ，这些构成了线程的上下文 (context) 。
* **Linux 线程:**  Linux 称线程为“任务” (tasks) 。通过 `clone()` 系统调用创建 ，`clone()` 允许子任务共享父任务（进程）的地址空间 。
* **Java 线程:**  线程由 Java 虚拟机 (JVM) 管理 。可以通过继承 `Thread` 类或实现 `Runnable` 接口来创建 。Java 线程有多种状态，如新建 (new)、可运行 (runnable)、阻塞 (blocked) 和死亡 (dead) 。