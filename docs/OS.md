# 操作系统

!!! Abstract
    
    **授课教师**：寿黎但


用户程序对内存的视图和内核程序对内存的视图**不一样**。那我们在系统调用时，我们如何规划一块内存存放参数，内核又如何知道到哪里去访问参数呢？

??? Success

    我们一般有三种方法

### 系统调用(System Call)的类型

- Process Control

- File Management

- Device Management

- Information Maintenance

- Communications

- Protections

### 系统程序(System Programs)

??? Note "系统调用和系统程序的区别"


## Chapter 2: OS Structures

## 进程 Process

### 1. 进程概念 (Process Concept)

* **定义**：进程是<u>“一个正在执行中的程序”</u>。操作系统执行各种程序，例如批处理系统中的“作业”（jobs）或时间共享系统中的“用户程序”或“任务”（tasks）。

<!-- fence:start -->
* **进程的内存结构**：一个进程在内存中包含：
    * **文本区域 (text section)**：即代码 (code)；
    * **程序计数器 (program counter)**；
    * **栈 (stack)**：用于存放函数参数、局部变量和返回地址；
    * **数据区域 (data section)**：存放全局变量；
    * **堆 (heap)**：用于动态分配内存。
<!-- fence -->
<img src="images/OS/image.png" alt="Process in Memory" style="zoom 60%"/>
<!-- fence:end -->

### 2. 进程状态 (Process State)

进程在其执行过程中会改变状态。

* **new (新建)**：进程正在被创建；
* **running (运行)**：指令正在被执行；
* **waiting (等待)**：进程正在等待某个事件发生（例如I/O完成）；
* **ready (就绪)**：进程等待被分配到处理器；
* **terminated (终止)**：进程已完成执行；



### 3. 进程控制块 (PCB)

* **定义**：PCB是与每个进程相关联的信息集合。
* **包含信息**：
    * 进程状态
    * 程序计数器
    * CPU寄存器内容
    * CPU调度信息
    * 内存管理信息
    * 记账信息
    * I/O状态信息
* **上下文切换 (Context Switch)**：当CPU切换到另一个进程时，系统必须保存旧进程的状态（到PCB）并加载新进程的保存状态。这个过程是开销，因为系统在切换时不做有用功。

### 4. 进程调度 (Process Scheduling)

这部分介绍了操作系统如何管理和调度进程。

* **调度队列 (Queues)**：
    * **作业队列 (Job queue)**：系统中所有的进程集合。
    * **就绪队列 (Ready queue)**：所有在主存中、准备好并等待执行的进程集合。
    * **设备队列 (Device queues)**：等待I/O设备的进程集合。
    * 进程会在这些队列之间迁移。
* **调度程序 (Schedulers)**：
    * **长期调度程序 (Long-term scheduler)**：也称“作业调度程序”，它选择哪些进程应被带入内存（就绪队列）。它控制着多道程序的程度，并且调用频率很低（秒或分钟）。
    * **短期调度程序 (Short-term scheduler)**：也称“CPU调度程序”，它选择下一个应该执行的进程并分配CPU。它的调用频率非常高（毫秒级），必须很快。
    * PPT提到，UNIX和Windows不使用长期调度程序。
    * 还提到了**中期调度 (Medium Term Scheduling)**，涉及将进程换出内存。
* **进程类型**：
    * **I/O密集型 (I/O-bound)**：花费更多时间进行I/O，有许多短暂的CPU爆发。
    * **CPU密集型 (CPU-bound)**：花费更多时间进行计算，有少数很长的CPU爆发。

### 5. 进程操作 (Operations on Processes)

这部分讨论了进程的创建和终止。

* **进程创建 (Process Creation)**：
    * 父进程创建子进程，形成一个进程树。
    * **资源共享**：父子进程可以共享所有资源、部分资源 或不共享资源。
    * **执行**：父子进程可以并发执行，或者父进程等待子进程终止。
    * **UNIX 示例**：`fork()` 系统调用用于创建新进程。`exec()` 系统调用通常在 `fork()` 之后使用，用一个新程序替换进程的内存空间。PPT中提供了一个C语言示例代码。
* **进程终止 (Process Termination)**：
    * 进程执行最后一条语句并请求操作系统删除它（例如调用 `exit`）。
    * 父进程可以终止子进程的执行（例如调用 `abort`），原因可能包括子进程超出了分配的资源 或分配给子进程的任务不再需要。
    * **级联终止 (Cascading termination)**：如果父进程退出，其所有子进程也可能被终止。
    * 在某些系统中，子进程可能成为“孤儿”进程，并被“init”进程（PID=1）收养。PPT指出在MacOS上，这个进程被称为 `launchd`。

### 6. 协作进程 (Cooperating Processes)

* **独立进程**不受其他进程影响，而**协作进程**可以影响或被其他进程影响。
* **协作的优势**：信息共享、计算加速（多CPU）、模块化 和方便性。
* **生产者-消费者问题 (Producer-Consumer Problem)**：
    * 这是一个协作进程的范例。生产者进程生产信息，消费者进程消费信息。
    * **有界缓冲区 (bounded-buffer)** 假定缓冲区大小固定。PPT提供了使用共享内存解决有界缓冲区问题的伪代码 [cite: 156-183]。

### 7. 进程间通信 (Interprocess Communication, IPC)

这部分介绍了进程间通信和同步的机制。

* **两种模型**：
    * **共享内存 (Shared memory)**
    * **消息传递 (Message passing)**
* **消息传递**：
    * 提供 `send(message)` 和 `receive(message)` 操作。
    * **直接通信**：进程必须显式地命名对方（例如 `send(P, ...)`）。
    * **间接通信**：消息被发送到“邮箱”（mailboxes）或“端口”（ports）。进程通过共享邮箱进行通信。
* **同步 (Synchronization)**：
    * 消息传递可以是**阻塞的（同步）** 或**非阻塞的（异步）**。
    * `阻塞发送`：发送方被阻塞，直到消息被接收。
    * `阻塞接收`：接收方被阻塞，直到有消息可用。
* **缓冲 (Buffering)**：
    * 通信链接上的消息队列可以有**零容量**、**有界容量** 或**无限容量**。

### 8. 客户端-服务器系统中的通信

这部分介绍了几种用于客户-服务器模型的IPC机制。

* **套接字 (Sockets)**：
    * 定义为通信的“端点”（endpoint）。
    * 是IP地址和端口号的组合（例如 `161.25.19.8:1625`）。
    * 通信在**一对套接字**之间进行。
* **远程过程调用 (Remote Procedure Calls, RPC)**：
    * 它抽象了网络系统中进程之间的过程调用。
    * 使用**存根 (Stubs)** 作为服务器上实际过程的客户端代理。
    * 客户端存根定位服务器并**编组 (marshals)** 参数。服务器端存根接收消息，**解组 (unpacks)** 参数，并执行过程。
* **远程方法调用 (Remote Method Invocation, RMI)**：
    * 这是Java中类似RPC的机制。
    * 它允许一台机器上的Java程序调用一个**远程对象**上的方法。

---

您是否希望我针对某个特定主题（例如进程调度、进程间通信或RPC）进行更深入的解释？