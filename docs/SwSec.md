
## Return-to-libc



## Shellcode 相关

在代码注入攻击中，攻击者会将恶意代码注入目标程序的内存空间。自然地，攻击者最理想的注入命令是能获得持续执行任意命令的能力，而启动 shell 程序（如 `/bin/sh`）正是实现该目标的终极方案。这类专用于启动 shell 的注入代码被称为 shellcode。

shellcode 高度依赖处理器架构，我们选择 **Intel 架构**来进行讲解，主要涵盖 x86（32 位）和 x64（64 位）两种架构。后面章节将重点解析 32 位 shellcode 的实现原理，64 位 shellcode 将在后面专门讨论。值得注意的是，尽管现代计算机多为 64 位架构，但仍保持对 32 位程序的兼容执行能力。

### 机器码

在利用 shellcode 进行攻击时，我们需要获取其机器码，而非包含额外数据的独立可执行文件。严格来说，只有机器码部分才被称为 shellcode。因此需从可执行文件或目标文件中提取纯机器码。有多种方法可实现此目的，其中一种是使用 `objdump` 命令进行反汇编。

### Shellcode 基本原理

这里只详细介绍汇编实现的原理。由于 C 语言生成的汇编程序存在一些问题，我们无法直接使用 C 程序生成的二进制代码作为攻击载荷，而需要通过汇编语言直接编写。其核心逻辑与 C 程序相同：通过 `execve()` 系统调用执行 `"/bin/sh"`。在 x86 架构中，需设置以下**四个寄存器**：

- `eax`：必须设置为 11, 即 `execve()` 的系统调用号；

- `ebx`：需包含命令字符串（如 `"/bin/sh"`）的地址；

- `ecx`：需包含参数数组地址；

- `edx`：需包含要传递给新程序的环境变量地址，若无环境变量需传递，可设为 0。

在设置寄存器的过程中，我们需要确定其载入内存后的实际地址，以便我们设置 `ebx` 和 `ecx` 寄存器。

#### 方法一：利用栈

该技术的核心思想是通过 `push` 指令将所需数据动态压入栈中，并利用栈指针 `esp` 获取数据地址。由于 `esp` 始终指向栈顶（即最后压入的数据项地址），我们可以借此定位 shell 命令字符串和参数数组的地址。

- **获取字符串地址**

    字符串本质是连续的字节序列。由于栈从高地址向低地址增长，我们需要以逆序将其压入栈中。当字符串的首字节（即最后一个压入的元素）入栈后，`esp` 寄存器存储的就是该字符串的起始地址。

    在 x86 架构中，每条 `push` 指令会压入 4 字节数据，因此需将字符串按 4 字节分块。然而，字符串必须以 NULL 字符（即字节 0，而非字符’0’）结尾。因此我们需要在压入字符串前先压入 0 值。若直接使用 `push 0x00000000` 指令（前面提到， `push` 操作必须处理 4 字节数据），会导致 shellcode（机器码） 中出现 0 值字节，这是必须避免的。我们将采用**寄存器自异或归零法**解决该问题：当寄存器与自身进行异或运算时，其结果必然为零，随后可将该 0 值压入栈中。

    !!! Example "设置 `ebx` 寄存器"

        假设我们的命令字符串是 `/bin/sh`。这里需要注意，像这种字符串长度不是 4 的倍数时，我们通过添加额外斜杠将其扩展为 8 字节：修改为 `/bin//sh`。这种写法不影响功能，因为 `execve()` 系统调用会忽略冗余斜杠。

        根据上面的方法，设置 `ebx` 可以用以下方式实现：

        ```ASM
        xor eax, eax        ; 清零 eax 寄存器
        push eax            ; 压入字符串终止符 NULL ('\0')
        push "//sh"         ; 压入 "//sh" 的十六进制表示
        push "/bin"         ; 压入 "/bin" 的十六进制表示
        mov ebx, esp        ; 获取字符串起始地址
        ```
- **获取参数数组地址**

    

#### 方法二：利用代码段

还有另一种方法可以解决数据地址问题。在这种方法中，数据被存储在代码区域，其地址通过函数调用机制获取。