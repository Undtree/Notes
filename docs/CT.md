# 计算理论

!!! Abstract "授课信息"

    **授课教师**：顾实 / 金小刚（顾老师实际授课）
    
!!! Success "参考资料"

    请支持 [TonyCrane 的计算理论笔记](https://note.tonycrane.cc/cs/tcs/toc/)

!!! Tip "写在前面..."

    所谓计算理论，大致上说，就是计算机科学的理论基础。它以抽象的方式研究计算机“算什么”、“怎么算”、“算的代价”。

    在计算机科学中，对于同一个话题，我们主要研究**四类问题**：

    - **优化问题**。例如，找一个图的<u>最小</u>生成树。

    - **搜索问题**。例如，找一个权重和 $\le k$ 的生成树。

    - **决策问题**。例如，判断<u>是否存在</u>一个权重和 $\le k$ 的生成树。

    - **计数问题**。例如，一个图总共有多少权重和 $\le k$ 的生成树。

    在这其中，我们主要研究**决策问题**。

    - 输出简单，要么是 Yes，要么是 No。

    - 这也把所有的输入实例分成了两类：让答案为“是”的 Yes-instance 和让答案为“否”的 No-instance。

    - 由于**难度等价性**，研究了决策问题的难度，就基本掌握了其他问题的难度。

## 01 集合、关系（数学基础）

### 三种基础的证明方法

- **归纳法 (Induction)**

- **鸽笼原理**

- **对角线论法（反证法）** 

#### 康托尔定理 (Cantor's Theorem)

集合 $A$ 的幂集（所有子集的集合）$P(A)$ 的势严格大于 $A$ 的势，即 $\text{card}(A) < \text{card}(P(A))$ 对所有集合 $A$ 都成立。

??? Success "证明"

    令 $f$ 是一个从 $A$ 到其幂集 $P(A)$ ($2^A$) 的映射。显然地，$\text{card}(A) \le \text{card}(P(A))$。

    我们需要证明 $A \neq P(A)$，即我们要证明这个单射(injection) $f$ 不能是满射的(surjective)。

    采取反证法。构造一个集合 $B = \{x \in A \mid x \notin f(x)\}$。由于假设 $f$ 是满射，那么在 $A$ 中必然存在一个元素 $t$，使得 $f(t) = B$。接下来考虑 $t$ 与 $B$ 的关系：
        
    - **如果 $t \in B$**：那么根据集合 $B$ 的定义，可知 $t \notin f(t)$。但由于我们假设了 $f(t) = B$，这推导出了 $t \notin B$，产生**矛盾**。
        
    -  **如果 $t \notin B$**：那么根据集合 $B$ 的定义，可知 $t \in f(t)$。同样由于 $f(t) = B$，这推导出了 $t \in B$，再次产生**矛盾**。

证明的核心就是“对角线论法”。

!!! Example "Considering the set $T$ of all infinite sequences of binary digits (i.e. each digit is zero or one).<br>Is $T$ countable?"

    $T$ is **uncountable**（$T$ 不可数）。

    我们注意到，我们可以将 $T$ 中的某个序列 $s$ 中 1 的位置表示为自然数集的子集，例如对于 $\{ 1, 4 \}$，我们可以解释为 $s$ 只有第 1 和第 4 位是 1（从 0 开始计，当然不从 0 也无所谓），其余位置为 0 。这样，$T$ 和自然数集 $\mathbb N$ 的幂集 $P(\mathbb N)$ 存在一一对应关系（存在一个双射）。那么，$| T | = | P(\mathbb N) |$。

    由康托尔定理，我们有：

    $$|\mathbb N| < |P(\mathbb N)|$$

    因此，$| T | > | \mathbb N |$；我们无法做到为每一个可能的无限序列编号，因此 $T$ 不可数。事实上，可数的数学定义就是存在一个从 $S$ 到自然数集 $\mathbb N$ 的单射 (Injection) 函数（直观地说，能以自然数编号）。

### 闭包及其性质

如果一个集合中的元素在进行某种运算后，结果仍然在该集合中，称该集合对该运算**封闭 (closed)**。

例如，自然数集对加法封闭，但对减法不封闭。整数 $\mathbb Z$ 是包含 $\mathbb N$ 且对减法封闭的最小集合，那么 $\mathbb Z$ 就是 $\mathbb N$ 在减法下的**闭包 (closure)**（The set $\mathbb Z$ is called a **closure** of $\mathbb N$ **under** subtraction.）。

#### 关系的闭包

简单来说，关系 $R$ 的闭包就是通过给关系添加**最少数量**的新元素，来使得添加之后的关系 $R'$ 满足一定的性质 $P$，这个新的关系 $R'$ 就被称为关系 $R$ 关于性质 $P$ 的闭包。

??? "正式定义"

    假设 $R$ 是集合 $A$ 上的一个二元关系，$P$ 是某种性质（如自反性、对称性或传递性）。如果存在另一个关系 $R'$，满足以下三个条件，则称 $R'$ 是 $R$ 关于性质 $P$ 的闭包：
    1. **包含性**：$R \subseteq R'$ （原有的关系都在里面）。
    2. **性质性**：$R'$ 具有性质 $P$。
    3. **最小性**：对于任何包含 $R$ 且具有性质 $P$ 的关系 $S$，都有 $R' \subseteq S$（它是满足条件的所有关系中“最小”的那一个，不多加任何没用的元素）。

最常用的闭包有三种，**自反 (Reflexive)、对称 (Symmetric)、传递 (Transitive)**。读者可以回顾离散数学课程的相关内容。

- 我们一般将关系 $R$ 的**自反传递**闭包记为 $R^\ast$ 。其定义是

$$
R^\ast = \{(a,b) | a,b \in A~\text{and there is path from}~a~\text{to}~b ~\text{in}~R\}
$$

- 我们一般将关系 $R$ 的**传递**闭包记为 $R^+$ 。

## 02 形式语言的理论基础

!!! Question "我们为什么要这样抽象地研究它？"

    总感觉这里解释的不太好。回来再想想怎么解释，先复习吧。
    
    考虑一个决策问题。它完全可以抽象为：**给定一个串 $w$，判断 $w$ 是否属于所有 yes-instance 编码的集合 $L$**。这里的 $L$ 也就是语言。

首先我们想一门人类的语言。无论它有没有文字，一门语言总是包含一些音素。它们的组合可以表达一个词语、短语或者句子，组成各种表达。研究表明，人类可以发出的音素数量是有限的。

### 2.1 符号化表示

我们定义：

- **字母表 (Alphabet，记为 $\Sigma$)**：一个<font color="red">**有限**</font>集合。集合内的元素被称作符号 (Symbols)。

- **字符串 (String)**：由 $\Sigma$ 中的符号组成的<font color="red">**有限**</font>序列，称作 String over $\Sigma$ 。

    - 空串 ($\varepsilon$ 或者 $e$)：长度为 0 的字符串。

    - $\Sigma^\ast$ 表记字母表 $\Sigma$ 上所有可能字符串的集合；
    
        $\Sigma^+$ 表记字母表 $\Sigma$ 上所有非空字符串的集合（正闭包）；
      
        $\Sigma^i$ 表记字母表 $\Sigma$ 上所有长度为 $i$ 的字符串。
      
        所以 $\Sigma^\ast = \bigcup_{i \ge 0}\Sigma^i$，$\Sigma^+ = \bigcup_{i \ge 1}\Sigma^i$。

- **语言 (Language)**：是 $\Sigma^\ast$ 的任意子集（$L \subseteq \Sigma^\ast$）。对于有无限个串的语言，我们通常用下面的形式表示：

$$
L = \{w \in \Sigma^\ast: w~\text{有性质}~P\}
$$

### 2.2 字符串运算

*   **连接 (Concatenation)**：$xy$。
*   **幂运算 (Exponentiation)**：$w^k$ 表示 $w$ 重复 $k$ 次。$w^0 = \varepsilon$。
*   **反转 (Reversal)**：$w^R$。归纳定义：$\varepsilon^R = \varepsilon$, $(ua)^R = a u^R$。

### 2.3 语言

*   **基数悖论**：
    *   对于一个字母表 $\Sigma$（有限），字符串集 $\Sigma^*$ 是可数（可数无限）的。语言总是 $\Sigma^*$ 的子集，所以一个语言总是可数的。
        
        ??? Success "证明"
            证明 $\Sigma^*$ 可数，也就是需要构建一个双射 $f: \mathbb N \to \Sigma^*$。

            *   我们不妨给字母表里的符号按照某种顺序固定：$\Sigma = \{a_1, a+2, ..., a_n\}$。
            *   对于字符串集的每一个串，
                *   按长度排：长度短的字符串永远排在长度长的字符串前面。
                *   同长度按字母表中的顺序排：如果长度一样，就按照预先定好的字母表顺序来排。
            
            这样，每一个串都有一个确定的位置，每一个自然数都对应了一个唯一的字符串（长度 + 字典定位）。

    *   **语言的集合**（即 $P(\Sigma^*)$）是**不可数**的（由康托尔定理）。一个非空字母表形成的所有语言的数量是 $|\mathbb R|$。更一般的，一个可数无限集的幂集的势总是 $|\mathbb R|$。
    
    不可判定性：计算机程序/算法/正则表达式是有限长度的字符串，因此只有可数无限多个程序。这意味存在**无数个无法被计算机描述或解决的语言（问题）**。

### 2.4 语言的运算

*   **集合运算**：并 ($\cup$)、交 ($\cap$)、补 ($\bar{L} = \Sigma^* - L$)、差 ($-$)。

*   **连接 (Concatenation)**：$L_1 L_2 = \{xy \mid x \in L_1, y \in L_2\}$。

*   <u>**克林星号 (Kleene Star, $L^*$)**：</u>
    *   定义：从 $L$ 中取任意个（包括0个）字符串进行连接所组成的所有字符串的集合。
    *   $L^* = \bigcup_{i \ge 0} L^i = L^0 \cup L^1 \cup L^2 \dots$
        
        我们以 $L^k$ 表示从 $L$ 中任取 $k$ 个字符串所有可能的集合。

    *   总是包含 $\varepsilon$，因为 $L^0 = \{\varepsilon\}$。

*   **正闭包 ($L^+$)**：$L^+ = LL^* = \bigcup_{i \ge 1} L^i$。
    *   如果不包含空串的组合，则 $L^+$ 不含 $\varepsilon$。

### 2.5 语言的有限表示法：正则表达式

由于许多语言是无限集，我们想要一种有限的方式来描述它们。

#### 定义

正则表达式采用递归定义法。它是定义在字母表 $\Sigma \cup \{(,),\cup,\ast\}$ 上的字符串。

1.  **基础 (原子性，Atomic)**：$\emptyset$ 和 $\{a\}$ (其中 $a \in \Sigma$) 是正则表达式。$\varepsilon$ (或 $\{e\}$) 也是。
2.  **归纳 (组合性，Composite)**：如果 $\alpha, \beta$ 是正则表达式，则以下也是：
    *   $\alpha \cup \beta$。
    *   $\alpha \circ \beta$（也表示成 $\alpha \beta$）。
    *   $\alpha^*$，表示克林星号（重复）。

其实就类似于各编程语言中使用的正则表达式，不过那些“正则表达式”一般都加了不属于这里规定的正则表达式的更多功能。

#### 表示

函数 $\mathcal{L}(r)$ 将正则表达式 $r$ 映射到它所代表的语言。

*   $\mathcal{L}(\emptyset) = \emptyset$

*   $\mathcal{L}(a) = \{a\}$

*   $\mathcal{L}(\alpha \cup \beta) = \mathcal{L}(\alpha) \cup \mathcal{L}(\beta)$

*   $\mathcal{L}(\alpha \beta) = \mathcal{L}(\alpha) \circ \mathcal{L}(\beta)$

*   $\mathcal{L}(\alpha^*) = (\mathcal{L}(\alpha))^*$

**克林定理 (Kleene's Theorem)** 指出，一个语言是正则的，**当且仅当**它可以被某个正则表达式描述。

!!! Note "正则语言的三个性质"
    
    1. 每个能用正则表达式表示的语言，都可以用无穷多个不同的正则表达式来表示。（正则表达式和正则语言是多对一的关系。）

    2. 正则语言类是由基本语言（单个字符和空集）在并、连接和克林星号运算下的闭包。（请参考正则表达式的递归定义。）

    3. 正则表达式在通用性上是不充分的。例如 $\{0^n 1^n : n \ge 0\}$ 无法被正则表达式描述。（正则表达式本质上对应于有限状态自动机（DFA，后面讲到）。DFA 的状态是有限的，它无法记住“已经读入了多少个 0”，即缺乏计数能力。）


#### 重要恒等式 (Identities)

*   $SR \ne RS$ (连接不满足交换律)
*   $S \cup R = R \cup S$ (并集满足交换律)
*   $R(ST) = (RS)T$ (连接结合律)
*   $R(S \cup T) = RS \cup RT$，$(R \cup S)T = RT \cup ST$ (分配律)
*   $\emptyset^* = \{ e \}$ (空集的星号是含空串的集合) $= e^* $
*   

#### 生成器 vs 识别器
这是计算理论中描述语言的两种视角：
1.  **生成器 (Generator)**：
    *   **代表**：正则表达式。
    *   **机制**：给出一套蓝图或指令，展示如何**构造**出语言中的字符串（例如：“先写个a，再写任意个b...”）。
2.  **识别器 (Recognition Device)**：
    *   **代表**：有限自动机 (DFA/NFA)。
    *   **机制**：输入一个字符串，机器内部状态流转，最后输出 **Yes/No** 来判定该字符串是否属于该语言。

!!! "补充"

在实际应用（如编程）中，我们常用：
*   $\Sigma$：表示任意一个字符（课件 Slide 21 中的 $10^* \cup \dots$ 例子中 implied 了通配符的概念）。
*   $R^+$：$RR^*$。

*   $\emptyset$ vs $\{\epsilon\}$：
    *   $\emptyset$ 是空语言，没有元素。
    *   $\{\epsilon\}$ 是只包含空串的语言，有一个元素（长度为0的串）。
    *   在连接运算中：$L \circ \emptyset = \emptyset$，但 $L \circ \{\epsilon\} = L$。
*   $L^*$ 总是包含 $\epsilon$，即使 $L$ 本身不包含。若 $L=\emptyset$，则 $L^* = \{\epsilon\}$。

## 03 正则语言与有限自动机

