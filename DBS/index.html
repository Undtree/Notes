
<!DOCTYPE html>

<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="../CA/" rel="prev"/>
<link href="../Crypto/" rel="next"/>
<link href="../assets/images/favicon.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.14" name="generator"/>
<title>数据库系统 - Undertree's 小站</title>
<link href="../assets/stylesheets/main.342714a4.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CJetBrains+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"JetBrains Mono"}</style>
<link href="https://cdn.jsdelivr.net/npm/jetbrains-mono@1.0.6/css/jetbrains-mono.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="../stylesheet/extra.css" rel="stylesheet"/>
<link href="../stylesheet/card.css" rel="stylesheet"/>
<script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
</head>
<body dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#relational-model">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header md-header--shadow" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="Undertree's 小站" class="md-header__button md-logo" data-md-component="logo" href=".." title="Undertree's 小站">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 4v6l-2-2-2 2V4H9v16h10V4zM3 7V5h2V4a2 2 0 0 1 2-2h12c1.05 0 2 .95 2 2v16c0 1.05-.95 2-2 2H7c-1.05 0-2-.95-2-2v-1H3v-2h2v-4H3v-2h2V7zm2-2v2h2V5zm0 14h2v-2H5zm0-6h2v-2H5z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            Undertree's 小站
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              数据库系统
            
          </span>
</div>
</div>
</div>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<a aria-label="分享" class="md-search__icon md-icon" data-clipboard="" data-clipboard-text="" data-md-component="search-share" href="javascript:void(0)" tabindex="-1" title="分享">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"></path></svg>
</a>
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
<div class="md-search__suggest" data-md-component="search-suggest"></div>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/Undertree/Notes/" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    TonyCrane/Notes
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="Undertree's 小站" class="md-nav__button md-logo" data-md-component="logo" href=".." title="Undertree's 小站">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 4v6l-2-2-2 2V4H9v16h10V4zM3 7V5h2V4a2 2 0 0 1 2-2h12c1.05 0 2 .95 2 2v16c0 1.05-.95 2-2 2H7c-1.05 0-2-.95-2-2v-1H3v-2h2v-4H3v-2h2V7zm2-2v2h2V5zm0 14h2v-2H5zm0-6h2v-2H5z"></path></svg>
</a>
    Undertree's 小站
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/Undertree/Notes/" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    TonyCrane/Notes
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    Home
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
<span class="md-ellipsis">
    数学
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_2_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
            数学
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../NA/">
<span class="md-ellipsis">
    数值分析
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
<span class="md-ellipsis">
    外语
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_3_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
            外语
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../JPN/">
<span class="md-ellipsis">
    日语(日本語)
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
<span class="md-ellipsis">
    CS相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="true" aria-labelledby="__nav_4_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
            CS相关
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../CA/">
<span class="md-ellipsis">
    计算机体系结构
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    数据库系统
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
<span class="md-ellipsis">
    数据库系统
    
  </span>
</a>
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#relational-model">
<span class="md-ellipsis">
      Relational Model
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#relational-algebra">
<span class="md-ellipsis">
      Relational Algebra
    </span>
</a>
<nav aria-label="Relational Algebra" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
<span class="md-ellipsis">
      基础操作
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
<span class="md-ellipsis">
      进阶操作
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sql">
<span class="md-ellipsis">
      SQL
    </span>
</a>
<nav aria-label="SQL" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#sql_2">
<span class="md-ellipsis">
      SQL数据类型
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sql_3">
<span class="md-ellipsis">
      SQL语句规范
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sql_4">
<span class="md-ellipsis">
      高级SQL
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
<span class="md-ellipsis">
      数据库设计范式
    </span>
</a>
<nav aria-label="数据库设计范式" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#e-r">
<span class="md-ellipsis">
      E-R模型
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
<span class="md-ellipsis">
      存储
    </span>
</a>
<nav aria-label="存储" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
<span class="md-ellipsis">
      存储层级
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
<span class="md-ellipsis">
      磁盘存储接口
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
<span class="md-ellipsis">
      磁盘工作机制
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
<span class="md-ellipsis">
      磁盘性能评估
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#flash-storage">
<span class="md-ellipsis">
      闪存 Flash Storage
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
<span class="md-ellipsis">
      数据存储结构
    </span>
</a>
<nav aria-label="数据存储结构" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
<span class="md-ellipsis">
      单条记录
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#slotted-page">
<span class="md-ellipsis">
      槽式页(Slotted Page)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
<span class="md-ellipsis">
      文件记录组织
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#data-dictionary-storage">
<span class="md-ellipsis">
      数据字典存储(Data Dictionary Storage)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
<span class="md-ellipsis">
      缓冲区/缓存
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing">
<span class="md-ellipsis">
      索引(Indexing)
    </span>
</a>
<nav aria-label="索引(Indexing)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
<span class="md-ellipsis">
      有序索引和无序索引
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b">
<span class="md-ellipsis">
      B+树索引
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
<span class="md-ellipsis">
      内存索引优化
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
<span class="md-ellipsis">
      高级索引
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
<span class="md-ellipsis">
      写入优化索引
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
<span class="md-ellipsis">
      查询处理
    </span>
</a>
<nav aria-label="查询处理" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#selection">
<span class="md-ellipsis">
      选择(Selection)操作
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sorting">
<span class="md-ellipsis">
      排序(Sorting)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#join">
<span class="md-ellipsis">
      连接(Join)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
<span class="md-ellipsis">
      查询优化
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#transaction">
<span class="md-ellipsis">
      事务(Transaction)
    </span>
</a>
<nav aria-label="事务(Transaction)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#acid">
<span class="md-ellipsis">
      ACID
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
<span class="md-ellipsis">
      并发控制
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_27">
<span class="md-ellipsis">
      并发控制实现
    </span>
</a>
<nav aria-label="并发控制实现" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#lock-based-protocols">
<span class="md-ellipsis">
      Lock-Based Protocols
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#two-phase-locking-2pl-protocol">
<span class="md-ellipsis">
      Two-Phase Locking (2PL) Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_28">
<span class="md-ellipsis">
      死锁处理
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tree-based-protocol">
<span class="md-ellipsis">
      Tree-Based Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-granularity-locking">
<span class="md-ellipsis">
      多粒度锁(Multiple Granularity Locking)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_29">
<span class="md-ellipsis">
      错误恢复
    </span>
</a>
<nav aria-label="错误恢复" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_30">
<span class="md-ellipsis">
      日志
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../Crypto/">
<span class="md-ellipsis">
    密码学
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
<span class="md-ellipsis">
    数据结构与算法分析
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_4_4_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_4_4">
<span class="md-nav__icon md-icon"></span>
            数据结构与算法分析
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../FDS/">
<span class="md-ellipsis">
    FDS
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../OOP/">
<span class="md-ellipsis">
    面向对象程序设计(in C++)
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">
<span class="md-ellipsis">
    编译原理
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#relational-model">
<span class="md-ellipsis">
      Relational Model
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#relational-algebra">
<span class="md-ellipsis">
      Relational Algebra
    </span>
</a>
<nav aria-label="Relational Algebra" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
<span class="md-ellipsis">
      基础操作
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
<span class="md-ellipsis">
      进阶操作
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sql">
<span class="md-ellipsis">
      SQL
    </span>
</a>
<nav aria-label="SQL" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#sql_2">
<span class="md-ellipsis">
      SQL数据类型
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sql_3">
<span class="md-ellipsis">
      SQL语句规范
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sql_4">
<span class="md-ellipsis">
      高级SQL
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
<span class="md-ellipsis">
      数据库设计范式
    </span>
</a>
<nav aria-label="数据库设计范式" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#e-r">
<span class="md-ellipsis">
      E-R模型
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
<span class="md-ellipsis">
      存储
    </span>
</a>
<nav aria-label="存储" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
<span class="md-ellipsis">
      存储层级
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
<span class="md-ellipsis">
      磁盘存储接口
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
<span class="md-ellipsis">
      磁盘工作机制
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
<span class="md-ellipsis">
      磁盘性能评估
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#flash-storage">
<span class="md-ellipsis">
      闪存 Flash Storage
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
<span class="md-ellipsis">
      数据存储结构
    </span>
</a>
<nav aria-label="数据存储结构" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
<span class="md-ellipsis">
      单条记录
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#slotted-page">
<span class="md-ellipsis">
      槽式页(Slotted Page)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
<span class="md-ellipsis">
      文件记录组织
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#data-dictionary-storage">
<span class="md-ellipsis">
      数据字典存储(Data Dictionary Storage)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
<span class="md-ellipsis">
      缓冲区/缓存
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing">
<span class="md-ellipsis">
      索引(Indexing)
    </span>
</a>
<nav aria-label="索引(Indexing)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
<span class="md-ellipsis">
      有序索引和无序索引
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b">
<span class="md-ellipsis">
      B+树索引
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
<span class="md-ellipsis">
      内存索引优化
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
<span class="md-ellipsis">
      高级索引
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
<span class="md-ellipsis">
      写入优化索引
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
<span class="md-ellipsis">
      查询处理
    </span>
</a>
<nav aria-label="查询处理" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#selection">
<span class="md-ellipsis">
      选择(Selection)操作
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sorting">
<span class="md-ellipsis">
      排序(Sorting)
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#join">
<span class="md-ellipsis">
      连接(Join)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
<span class="md-ellipsis">
      查询优化
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#transaction">
<span class="md-ellipsis">
      事务(Transaction)
    </span>
</a>
<nav aria-label="事务(Transaction)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#acid">
<span class="md-ellipsis">
      ACID
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
<span class="md-ellipsis">
      并发控制
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_27">
<span class="md-ellipsis">
      并发控制实现
    </span>
</a>
<nav aria-label="并发控制实现" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#lock-based-protocols">
<span class="md-ellipsis">
      Lock-Based Protocols
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#two-phase-locking-2pl-protocol">
<span class="md-ellipsis">
      Two-Phase Locking (2PL) Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_28">
<span class="md-ellipsis">
      死锁处理
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tree-based-protocol">
<span class="md-ellipsis">
      Tree-Based Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-granularity-locking">
<span class="md-ellipsis">
      多粒度锁(Multiple Granularity Locking)
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_29">
<span class="md-ellipsis">
      错误恢复
    </span>
</a>
<nav aria-label="错误恢复" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_30">
<span class="md-ellipsis">
      日志
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1>数据库系统</h1>
<div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;">
<p><span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8zm6.78 1a.7.7 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38z"></path></svg></span> 约 17797 个字 <span class="twemoji"><svg viewbox="0 0 640 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6m80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3"></path></svg></span> 69 行代码 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 17H7V3h14m0-2H7a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2M3 5H1v16a2 2 0 0 0 2 2h16v-2H3m12.96-10.71-2.75 3.54-1.96-2.36L8.5 15h11z"></path></svg></span> 42 张图片 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3z"></path></svg></span> 预计阅读时间 60 分钟</p>
</div>
<div class="admonition abstract">
<p class="admonition-title">Abstract</p>
<p><strong>课程信息</strong>
- 黄忠东老师授课。</p>
<ul>
<li>
<p>参考用书：《Database System Concept》, 7th Edition</p>
</li>
<li>
<p>Grading Policy</p>
</li>
</ul>
</div>
<div class="admonition 这门课讲什么">
<p class="admonition-title">这门课讲什么</p>
<p>在这门课程中，我们将学习到有严格事务要求(data access requirement)的结构化数据(data type)的管理。</p>
</div>
<div class="admonition success">
<p class="admonition-title">特别鸣谢🙇‍</p>
<ul>
<li>
<p>Github 上 [@yile-liu] (https://github.com/yile-liu/ZJU_database_system)老师的数据库系统笔记。</p>
</li>
<li>
<p>Chritch 老师的博客 <a href="https://obsidian.zerokei.top/Hub/Database%20System/">数据库系统篇</a></p>
</li>
<li>
<p>MEM 佬的博客 <a href="https://mem.ac">mem.ac</a></p>
</li>
</ul>
</div>
<!-- -->
<h2 id="relational-model">Relational Model<a class="headerlink" href="#relational-model" title="Permanent link">¶</a></h2>
<p>我们来看一个例子：</p>
<p><img alt="relation_example" src="../images/DB/db1.png"/></p>
<p>在这个例子中，蓝底的列名被称为<strong>attributes(属性)</strong>，下面的每一行被称为一个<strong>tuple(元组)</strong>。我们给定 <span class="arithmatex">\(A_1, A_2, …, A_n\)</span> 是一系列 attributes ，那么</p>
<div class="arithmatex">\[
R = (A_1, A_2, …, A_n )
\]</div>
<p>被称为<strong>relation schema</strong>。一般地，我们用 <span class="arithmatex">\(R\)</span> 等大写字母表记一个 relation schema ，用 <span class="arithmatex">\(r\)</span> 等小写字母表记一个 relation instance。</p>
<p>每一列的所有可取值(取值范围)被称为它的<strong>domain</strong>。我们给定列 <span class="arithmatex">\(A_i\)</span> 的 domain 是 <span class="arithmatex">\(D_i\)</span> ，那么从形式上说，一个<strong>关系(relation)</strong>就是 <span class="arithmatex">\(D_1 \times D_2 \times ... \times D_n\)</span> 的一个子集。</p>
<p>换句话说，一个 relation instance 就是一张表格，每一行代表一个事物，每一列代表一项属性。</p>
<p>一个<strong>数据库(Database)</strong>就是由多个 relation 组成的。这一点在后续 SQL 部分还会有所体现。</p>
<p>我们定义一个概念：<strong>键(key)</strong>，并规定键 <span class="arithmatex">\(K \subseteq R~\mbox{(Relation Schema)}\)</span>，键实际上就是一个列名。</p>
<ul>
<li>
<p><span class="arithmatex">\(K\)</span> is a <strong>superkey(超键)</strong> of <span class="arithmatex">\(R\)</span> if values for <span class="arithmatex">\(K\)</span> are sufficient to identify a unique tuple of each possible relation <span class="arithmatex">\(r\)</span>.</p>
</li>
<li>
<p>Superkey <span class="arithmatex">\(K\)</span> is a <strong>candidate key(候选键)</strong> if the number of attributes in <span class="arithmatex">\(K\)</span> is minimal (If we remove one more attribute in <span class="arithmatex">\(K\)</span>, <span class="arithmatex">\(K\)</span> will not be a superkey).</p>
<p>Note that <u>Candidate key can have more than one attribute</u>.</p>
</li>
<li>
<p>One of the candidate keys is selected to be the <strong>primary key(主键)</strong>.</p>
</li>
<li>
<p><strong>Foreign key(外键)</strong> constraint: Value in one relation must appear in another.</p>
<p>Assume there exists relations <span class="arithmatex">\(r\)</span> and <span class="arithmatex">\(s\)</span>: <span class="arithmatex">\(r(A,B,C)\)</span>, <span class="arithmatex">\(s(B,D)\)</span>, we can say that attribute <span class="arithmatex">\(B\)</span> in relation <span class="arithmatex">\(r\)</span> is foreign key referencing <span class="arithmatex">\(s\)</span>, and <span class="arithmatex">\(r\)</span> is a referencing relation, and <span class="arithmatex">\(s\)</span> is a referenced relation.</p>
<p>referencing relation 是“引用”，其表述的是外键所在的 relation ； referenced relation 是“被引用”，其表述的是被引用的键所在的 relation。</p>
</li>
</ul>
<h2 id="relational-algebra">Relational Algebra<a class="headerlink" href="#relational-algebra" title="Permanent link">¶</a></h2>
<p>需要注意：</p>
<ul>
<li>关系代数的输入和输出都是 relations。</li>
</ul>
<h3 id="_1">基础操作<a class="headerlink" href="#_1" title="Permanent link">¶</a></h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">选择</td>
<td style="text-align: center;"><span class="arithmatex">\(\sigma_{p}{(r)}\)</span></td>
<td style="text-align: center;">单关系操作。返回关系 <span class="arithmatex">\(r\)</span> 中满足关系式 <span class="arithmatex">\(p\)</span> 的元组的关系</td>
</tr>
<tr>
<td style="text-align: center;">投影</td>
<td style="text-align: center;"><span class="arithmatex">\(\Pi_{~A_1,A_2,...,A_3~}{(r)}\)</span></td>
<td style="text-align: center;">单关系操作。返回关系 <span class="arithmatex">\(r\)</span> 中属性为 <span class="arithmatex">\(A_1, A_2, ..., A_n\)</span> 的列并<strong>去重</strong></td>
</tr>
<tr>
<td style="text-align: center;">重命名</td>
<td style="text-align: center;"><span class="arithmatex">\(\rho_{x}{(E)}\)</span></td>
<td style="text-align: center;">单关系操作。将 <span class="arithmatex">\(E\)</span> 重命名为 <span class="arithmatex">\(x\)</span> 并返回</td>
</tr>
<tr>
<td style="text-align: center;">集合并</td>
<td style="text-align: center;"><span class="arithmatex">\(r \cup s\)</span></td>
<td style="text-align: center;">将两个属性数相等且所有属性的域相同的两个关系合并为同一个关系，并<strong>去重</strong></td>
</tr>
<tr>
<td style="text-align: center;">集合差</td>
<td style="text-align: center;"><span class="arithmatex">\(r - s\)</span></td>
<td style="text-align: center;">返回<u>属于关系 <span class="arithmatex">\(r\)</span> </u>却不出现在关系 <span class="arithmatex">\(s\)</span> 中的元组的关系</td>
</tr>
<tr>
<td style="text-align: center;">笛卡尔积</td>
<td style="text-align: center;"><span class="arithmatex">\(r \times s\)</span></td>
<td style="text-align: center;">返回任意两个关系的元组组合 (两个关系的属性应不相交，否则应重命名)</td>
</tr>
</tbody>
</table>
<h3 id="_2">进阶操作<a class="headerlink" href="#_2" title="Permanent link">¶</a></h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">集合交</td>
<td style="text-align: center;"><span class="arithmatex">\(r \cap s\)</span></td>
<td style="text-align: center;">取同时出现在两个关系中的元组，可转化为 <span class="arithmatex">\(r - (r - s)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">自然连接</td>
<td style="text-align: center;"><span class="arithmatex">\(r \bowtie s\)</span></td>
<td style="text-align: center;">取两个关系公共属性中具有<strong>相同属性值</strong>的元组进行拼接</td>
</tr>
<tr>
<td style="text-align: center;"><span class="arithmatex">\(\theta\)</span> 连接</td>
<td style="text-align: center;"><span class="arithmatex">\(r \bowtie_{\theta} s\)</span></td>
<td style="text-align: center;">返回满足关系式</td>
</tr>
<tr>
<td style="text-align: center;">除</td>
<td style="text-align: center;">$r \div s $</td>
<td style="text-align: center;"><span class="arithmatex">\(r \div s = \Pi_{R-S}(r) - \Pi_{R-S}\big( (\Pi_{R-S}(r) \times s - r \big)\)</span>，找出与“除数”关系中所有元组都有联系(能连接)的元组。<span class="arithmatex">\(R-S\)</span> 代表 <span class="arithmatex">\( r \)</span> 和 <span class="arithmatex">\( s \)</span> 的属性集差。</td>
</tr>
<tr>
<td style="text-align: center;">赋值</td>
<td style="text-align: center;"><span class="arithmatex">\(r \leftarrow E\)</span></td>
<td style="text-align: center;">将右边的计算结果赋值给左边的表</td>
</tr>
<tr>
<td style="text-align: center;"><br/>聚集</td>
<td style="text-align: center;"><br/><span class="arithmatex">\(_{G_1, G_2, ..., G_n}~\mathcal{G}_{F_1(A_1), F_2(A_2), ..., F_n(A_n)}{r}\)</span></td>
<td style="text-align: center;"><span class="arithmatex">\(G_i\)</span> 是用于分组的属性 (可为空) ，<span class="arithmatex">\(F_i\)</span> 是聚集函数 (反映在数据库中就是<code>sum</code>/<code>avg</code>等函数) ，<span class="arithmatex">\(A_i\)</span> 是属性名。聚集操作对一组值执行计算并返回单个值，它对数据集合进行"纵向"计算 (跨多行计算)。假设已经指定用于分组的属性，则按指定属性将关系划分为多个组，对每个组独立应用聚合函数，每组产生一个结果元组</td>
</tr>
</tbody>
</table>
<h2 id="sql">SQL<a class="headerlink" href="#sql" title="Permanent link">¶</a></h2>
<div class="admonition tip">
<p class="admonition-title">这个章节对应教材第 3-5 章。</p>
</div>
<p>SQL 全称结构化查询语言(Structured Query Language)。SQL 数据定义语言(DDL)允许定义以下关系信息：</p>
<ul>
<li>
<p>每个关系的模式(schema)</p>
</li>
<li>
<p>各属性关联的值类型</p>
</li>
<li>
<p>完整性约束</p>
</li>
<li>
<p>为每个关系维护的索引集合</p>
</li>
<li>
<p>关系的安全性与授权信息</p>
</li>
<li>
<p>关系在磁盘上的物理存储结构</p>
</li>
</ul>
<h4 id="sql_1">SQL 的历史发展<a class="headerlink" href="#sql_1" title="Permanent link">¶</a></h4>
<p>这里应该不考，暂时鸽了(</p>
<h3 id="sql_2">SQL 数据类型<a class="headerlink" href="#sql_2" title="Permanent link">¶</a></h3>
<div class="card">
<div class="card-header">char(n)</div>
<div class="card-body">
<p><strong>含义</strong>：定长为 n 的字符串</p>
</div>
</div>
<div class="card">
<div class="card-header">varchar(n)</div>
<div class="card-body">
<p><strong>含义</strong>：长度可变的字符串，最大长度为 n</p>
</div>
</div>
<div class="card">
<div class="card-header">varchar(n)</div>
<div class="card-body">
<p><strong>含义</strong>：长度可变的字符串，最大长度为 n</p>
</div>
</div>
<div class="card">
<div class="card-header">int</div>
<div class="card-body">
<p><strong>含义</strong>：整数。其数据范围是数学上的“整数”的一个<u>由库和计算机架构决定的</u>有限子集</p>
</div>
</div>
<div class="card">
<div class="card-header">smallint</div>
<div class="card-body">
<p><strong>含义</strong>：小整数。其数据范围是数学上的“整数”的一个<u>由库和计算机架构决定的</u>有限子集，只不过比 int 所包含的范围小。</p>
</div>
</div>
<div class="card">
<div class="card-header">numeric(p, d)</div>
<div class="card-body">
<p><strong>含义</strong>：十进制表示，总共有 p 位，其中小数点后有 d 位。</p>
<blockquote>
<p>例如对 numeric(3, 1)， 10.5、01.0 是合法的， 1.05、105、1 都是不合法的。</p>
</blockquote>
</div>
</div>
<div class="card">
<div class="card-header">float(n)</div>
<div class="card-body">
<p><strong>含义</strong>：<u>至少</u>有 n 个数字的浮点数。</p>
</div>
</div>
<div class="card">
<div class="card-header">real/double precision</div>
<div class="card-body">
<p><strong>含义</strong>：单精度浮点数和双精度浮点数。和 C 语言等的<code>float</code>/<code>double</code>大致对应。允许的数据范围<u>由库和计算机架构</u>决定。</p>
</div>
</div>
<p>SQL 还有一些关于时间的预设类型：</p>
<div class="card">
<div class="card-header">date</div>
<div class="card-body">
<p><strong>含义</strong>：日期，能且仅能包含(四位数字的)年份、月份和日期。</p>
<blockquote>
<p>例如"2025-6-9"、"2025-06-09"</p>
</blockquote>
</div>
</div>
<div class="card">
<div class="card-header">time</div>
<div class="card-body">
<p><strong>含义</strong>：时间，最大单位是小时，至少包含小时、分钟、秒。</p>
<blockquote>
<p>"18:12:20" 和 "18:12:20.111" 都是可接受的输入。虽然标准格式要求小时、分钟、秒都应该是 2 位数字，但大多数数据库系统在输入时允许省略前导 0。</p>
</blockquote>
</div>
</div>
<div class="card">
<div class="card-header">timestamp</div>
<div class="card-body">
<p><strong>含义</strong>：从组成上看就是 date+time。</p>
<blockquote>
<p>例如"2005-7-27 09:00:30.75"。</p>
</blockquote>
</div>
</div>
<div class="card">
<div class="card-header">interval</div>
<div class="card-body">
<p><strong>含义</strong>：描述一个时间段。interval 值可以被加在 date/time/timestamp 值上。</p>
</div>
</div>
<p>SQL 还有针对大型数据的表示方式。</p>
<div class="card">
<div class="card-header">blob</div>
<div class="card-body">
<p><strong>含义</strong>：二进制大对象，是一个可以存储二进制文件的容器。典型的 blob 是一张图片或者声音文件等。对其的解析会交给外部程序去运行，数据库只负责存储这些大对象。</p>
</div>
</div>
<div class="card">
<div class="card-header">clob</div>
<div class="card-body">
<p><strong>含义</strong>：字符大对象，是一个可以储存大段字符数据的容器。</p>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>需要注意的是，当一个查询操作需要查询一个大对象时，会返回给它一个指向这个对象的指针而非这个大对象本身。传指针可快多了！</p>
</div>
<p>SQL 还允许用户自定义类型(<code>create type</code>)。</p>
<h3 id="sql_3">SQL 语句规范<a class="headerlink" href="#sql_3" title="Permanent link">¶</a></h3>
<p>这里就不列出所有语法了，仅仅放一些个人觉得可能会错的地方。</p>
<p>SQL 所有的关键字都是<strong>大小写不敏感</strong>的。</p>
<div class="card">
<div class="card-header">建表</div>
<div class="card-body">
<p>一个例子：</p>
<div class="language-SQL highlight"><pre><span></span><code><span id="__span-0-1"><a href="#__codelineno-0-1" id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="p">(</span>
</span><span id="__span-0-2"><a href="#__codelineno-0-2" id="__codelineno-0-2" name="__codelineno-0-2"></a><span class="w">    </span><span class="n">ID</span><span class="w">             </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
</span><span id="__span-0-3"><a href="#__codelineno-0-3" id="__codelineno-0-3" name="__codelineno-0-3"></a><span class="w">    </span><span class="n">name</span><span class="w">           </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="p">,</span>
</span><span id="__span-0-4"><a href="#__codelineno-0-4" id="__codelineno-0-4" name="__codelineno-0-4"></a><span class="w">    </span><span class="n">dept_name</span><span class="w">      </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
</span><span id="__span-0-5"><a href="#__codelineno-0-5" id="__codelineno-0-5" name="__codelineno-0-5"></a><span class="w">    </span><span class="n">tot_cred</span><span class="w">       </span><span class="nb">numeric</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
</span><span id="__span-0-6"><a href="#__codelineno-0-6" id="__codelineno-0-6" name="__codelineno-0-6"></a><span class="w">    </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">ID</span><span class="p">),</span><span class="w">          </span><span class="c1">-- 声明为primary key的属性会自动确保其非空</span>
</span><span id="__span-0-7"><a href="#__codelineno-0-7" id="__codelineno-0-7" name="__codelineno-0-7"></a><span class="w">    </span><span class="k">foreign</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">dept_name</span><span class="p">)</span><span class="w"> </span><span class="k">references</span><span class="w"> </span><span class="n">department</span>
</span><span id="__span-0-8"><a href="#__codelineno-0-8" id="__codelineno-0-8" name="__codelineno-0-8"></a><span class="w">                               </span><span class="c1">-- references关键字后应该跟一个关系(table)名</span>
</span><span id="__span-0-9"><a href="#__codelineno-0-9" id="__codelineno-0-9" name="__codelineno-0-9"></a><span class="p">);</span>
</span></code></pre></div>
<div class="admonition note">
<p class="admonition-title">完整性约束(Integrity Constraint)</p>
<p>完整性约束即对 attribute 内容的约束，不满足约束条件的 tuple 不能被插入。一般有 5 类约束方法：</p>
<ul>
<li>
<p><code>not NULL</code>：限定该属性值非 NULL。</p>
</li>
<li>
<p><code>primary key</code>：声明为 primary key 的属性会自动确保其非空</p>
</li>
<li>
<p><code>foreign key</code>：某个表中被声明为外键的属性一定是另外某个表的主键。</p>
</li>
<li>
<p><code>check(&lt;predicate&gt;)</code>：自定义检查的条件，例如<code>CHECK (semester in ("spring", "autumn"))</code></p>
</li>
<li>
<p>自定义 domain ：例如<code>create domain person_name char(20) not null</code>。此操作在 SQL92 标准被引入，允许用户自定义一个 domain。其本质上是一种可重用的约束模板。其基本语法是：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-1-1"><a href="#__codelineno-1-1" id="__codelineno-1-1" name="__codelineno-1-1"></a><span class="k">CREATE</span><span class="w"> </span><span class="k">DOMAIN</span><span class="w"> </span><span class="n">domain_name</span><span class="w"> </span><span class="p">[</span><span class="k">AS</span><span class="p">]</span><span class="w"> </span><span class="err">数据类型</span>
</span><span id="__span-1-2"><a href="#__codelineno-1-2" id="__codelineno-1-2" name="__codelineno-1-2"></a><span class="w">    </span><span class="p">[</span><span class="k">DEFAULT</span><span class="w"> </span><span class="err">默认值</span><span class="p">]</span>
</span><span id="__span-1-3"><a href="#__codelineno-1-3" id="__codelineno-1-3" name="__codelineno-1-3"></a><span class="w">    </span><span class="p">[</span><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="err">约束条件</span><span class="p">)];</span>
</span></code></pre></div>
<p>然后你就可以使用这个值域了。例如：</p>
<p><div class="language-sql highlight"><pre><span></span><code><span id="__span-2-1"><a href="#__codelineno-2-1" id="__codelineno-2-1" name="__codelineno-2-1"></a><span class="k">CREATE</span><span class="w"> </span><span class="k">DOMAIN</span><span class="w"> </span><span class="n">Email</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span>
</span><span id="__span-2-2"><a href="#__codelineno-2-2" id="__codelineno-2-2" name="__codelineno-2-2"></a><span class="k">CHECK</span><span class="w"> </span><span class="p">(</span><span class="n">VALUE</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">'%@%.%'</span><span class="p">);</span>
</span><span id="__span-2-3"><a href="#__codelineno-2-3" id="__codelineno-2-3" name="__codelineno-2-3"></a>
</span><span id="__span-2-4"><a href="#__codelineno-2-4" id="__codelineno-2-4" name="__codelineno-2-4"></a><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Users</span><span class="w"> </span><span class="p">(</span>
</span><span id="__span-2-5"><a href="#__codelineno-2-5" id="__codelineno-2-5" name="__codelineno-2-5"></a><span class="w">    </span><span class="n">user_email</span><span class="w"> </span><span class="n">Email</span><span class="p">,</span><span class="w">  </span><span class="c1">-- 直接复用域定义</span>
</span><span id="__span-2-6"><a href="#__codelineno-2-6" id="__codelineno-2-6" name="__codelineno-2-6"></a><span class="w">    </span><span class="p">...</span>
</span><span id="__span-2-7"><a href="#__codelineno-2-7" id="__codelineno-2-7" name="__codelineno-2-7"></a><span class="p">);</span>
</span></code></pre></div>
它是基于现有类型的一种约束扩展，这一点和直接自定义类型(可以是完全独立的全新类型)有所不同。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="card">
<div class="card-header">查询</div>
<div class="card-body">
<p>一个典型的查询语句具有如下形式：</p>
<div class="language-SQL highlight"><pre><span></span><code><span id="__span-3-1"><a href="#__codelineno-3-1" id="__codelineno-3-1" name="__codelineno-3-1"></a><span class="k">select</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="n">A2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">An</span><span class="w">  </span><span class="c1">-- A_i 代表属性名</span>
</span><span id="__span-3-2"><a href="#__codelineno-3-2" id="__codelineno-3-2" name="__codelineno-3-2"></a><span class="k">from</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">rm</span><span class="w">    </span><span class="c1">-- r_i 代表关系名</span>
</span><span id="__span-3-3"><a href="#__codelineno-3-3" id="__codelineno-3-3" name="__codelineno-3-3"></a><span class="k">where</span><span class="w"> </span><span class="n">P</span><span class="w">                 </span><span class="c1">-- P 代表筛选条件</span>
</span></code></pre></div>
<p>select 可以细分为 select all 与 select distinct ，区别是是否为结果去重， select 不使用后缀时默认为 select all。select distinct 与关系代数的 <span class="arithmatex">\(\Pi\)</span> 等价，而 select all 则不然。</p>
<p>事实上，上述语句等价于关系代数表达式：</p>
<div class="arithmatex">\[
\Pi_{A1, \ldots, An} \left( \sigma_P (r1 \times r2 \times \ldots \times rm) \right)
\]</div>
<p>这里使用 <span class="arithmatex">\(\Pi\)</span> 会产生重复行的原因是，当关系中的两个元组各属性值完全相同时，<span class="arithmatex">\(\Pi\)</span> 才会去重，像这样先笛卡尔积后，虽然选定的属性值有重复，但是每个元组都不完全一样。 </p>
<p>需要注意的是，查询操作返回一个关系(table)。</p>
<div class="admonition tip">
<p class="admonition-title">非典型的用法</p>
<p>select 选择的内容也可以是表达式，例如<code>select salary/1000 from teacher;</code>返回的是 salary/1000 的结果。</p>
<p>也因此 select 可以没有 from 子句，一般用于展示数据或者赋值并展示结果，例如<code>select 12345/5;</code>单纯打印这个表达式的结果数字。</p>
<p>select 结果可以使用<code>order by ATTRIBUTE_NAME (desc/asc)</code>子句排序， desc/asc 表示按照降/升序，不显式指定默认为 asc。order by 后面可以跟多个 attribute ，以逗号分隔，靠前的优先。</p>
</div>
</div>
</div>
<div class="card">
<div class="card-header">别名</div>
<div class="card-body">
<p>as 可以为一个对象赋别名。当然， as 还可以为同一个对象赋两个别名以实现自我对比。但是， as 别名的作用域仅限于这条语句，实际名称并不会被更改，下图中的 select 语句完成后表名仍然叫 instructor。as 有时可以省略不写。</p>
<div class="language-SQL highlight"><pre><span></span><code><span id="__span-4-1"><a href="#__codelineno-4-1" id="__codelineno-4-1" name="__codelineno-4-1"></a><span class="k">select</span><span class="w"> </span><span class="k">distinct</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">name</span>
</span><span id="__span-4-2"><a href="#__codelineno-4-2" id="__codelineno-4-2" name="__codelineno-4-2"></a><span class="k">from</span><span class="w"> </span><span class="n">instructoras</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">instructor</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">S</span>
</span><span id="__span-4-3"><a href="#__codelineno-4-3" id="__codelineno-4-3" name="__codelineno-4-3"></a><span class="k">where</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">S</span><span class="p">.</span><span class="n">dept_name</span><span class="w"> </span><span class="o">=</span><span class="s1">'Comp.Sci.'</span>
</span></code></pre></div>
<p><code>instructor as T</code> = <code>instructor T</code>。但是，在 Oracle 中， as 必须被省略。</p>
</div>
</div>
<div class="card">
<div class="card-header">(字符串)模糊搜索</div>
<div class="card-body">
<p>like 是模糊搜索的关键字。SQL 字符串查找最常用的两个记号为<code>%</code>和<code>_</code>。<code>%</code>匹配任意字符串，<code>_</code>匹配任意单字符。</p>
<p>需要字符串查找内容本身包含<code>%</code>或<code>_</code>时使用逃逸字符<code>\%</code>、<code>\_</code>。字符串内容匹配默认区分大小写。</p>
<p><img alt="like_usage" src="../images/DB/db20.png"/></p>
</div>
</div>
<div class="card">
<div class="card-header">union/intersect/except</div>
<div class="card-body">
<p>它们三者各自都又有 all 和 distinct 两个版本，区别是结果是否去重，但是它们<strong>默认去重</strong>，这与 select 不同。</p>
<p><code>union</code>/<code>intersect</code>/<code>except</code>分别等价于交集、并集、集合的减法。</p>
</div>
</div>
<div class="card">
<div class="card-header">group by</div>
<div class="card-body">
<p>配合各类代数操作，功能等价于关系代数中 <span class="arithmatex">\(\mathcal{G}\)</span> 前部的下标。</p>
<p>group by<strong>先于 select 进行</strong>，创建一个仅包含代数操作列与 group by 列的临时表， select 操作在这个临时表中进行。</p>
<details class="danger">
<summary>由此带来的特性</summary>
<ul>
<li>select...group by...可以在多个列名和列数不完全相同的表中进行，只要共有用于代数操作和 group by 的列就可以了。例如下面的表 r1、r2 等只要共有 A1、A2(用于 group by)和 A3(用于 sum)即可，其余列无所谓。</li>
</ul>
<div class="language-SQL highlight"><pre><span></span><code><span id="__span-5-1"><a href="#__codelineno-5-1" id="__codelineno-5-1" name="__codelineno-5-1"></a><span class="k">select</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">A3</span><span class="p">)</span>
</span><span id="__span-5-2"><a href="#__codelineno-5-2" id="__codelineno-5-2" name="__codelineno-5-2"></a><span class="k">from</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="p">.</span>
</span><span id="__span-5-3"><a href="#__codelineno-5-3" id="__codelineno-5-3" name="__codelineno-5-3"></a><span class="k">where</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="n">A2</span>
</span></code></pre></div>
<ul>
<li>同时 select 代数操作和其他的列时，其他列必须同时放在 group by 里面，因为不能选择临时表中没有的列。</li>
</ul>
</details>
</div>
</div>
<div class="card">
<div class="card-header">where/having</div>
<div class="card-body">
<ul>
<li>
<p>where 在 group by 之前进行，不满足条件的 tuble 不会参与 group by 进入临时表。</p>
</li>
<li>
<p>having 在 group by 之后进行，在产生的临时表中筛选，只返回满足的 tuble。</p>
</li>
</ul>
<p>因此引申出 exists 只能跟 where ；代数操作做条件只能跟 having ；同样的语句在 where 和 having 之后效果不一定相同。下面是一个正确用法示例：</p>
<p><img alt="where_having_usage" src="../images/DB/db21.png"/></p>
</div>
</div>
<div class="card">
<div class="card-header">关于 NULL</div>
<div class="card-body">
<p>NULL 值不参与对列的代数函数运算，全 NULL 的 tuple 不会被 count()计数。没有非 NULL 元素时，代数操作返回 NULL ， count()返回 0。</p>
</div>
</div>
<div class="card">
<div class="card-header">some/all</div>
<div class="card-body">
<p>some/all 跟在关系符号( <span class="arithmatex">\(&lt;\)</span>/<span class="arithmatex">\(&gt;\)</span>/<span class="arithmatex">\(\leq\)</span>/<span class="arithmatex">\(\geq\)</span>/<span class="arithmatex">\(=\)</span>/<span class="arithmatex">\(\neq\)</span> )后， some 相当于于存在， all 相当于任意。当其后的表中元素满足前面的关系则返回 true。</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-6-1"><a href="#__codelineno-6-1" id="__codelineno-6-1" name="__codelineno-6-1"></a><span class="mi">5</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">some</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
</span><span id="__span-6-2"><a href="#__codelineno-6-2" id="__codelineno-6-2" name="__codelineno-6-2"></a><span class="mi">5</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">some</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span>
</span><span id="__span-6-3"><a href="#__codelineno-6-3" id="__codelineno-6-3" name="__codelineno-6-3"></a><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">some</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
</span><span id="__span-6-4"><a href="#__codelineno-6-4" id="__codelineno-6-4" name="__codelineno-6-4"></a><span class="mi">5</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">some</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
</span><span id="__span-6-5"><a href="#__codelineno-6-5" id="__codelineno-6-5" name="__codelineno-6-5"></a><span class="c1">-- (=some) = in 但是 ( != some) != not in</span>
</span><span id="__span-6-6"><a href="#__codelineno-6-6" id="__codelineno-6-6" name="__codelineno-6-6"></a>
</span><span id="__span-6-7"><a href="#__codelineno-6-7" id="__codelineno-6-7" name="__codelineno-6-7"></a><span class="mi">5</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">all</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span>
</span><span id="__span-6-8"><a href="#__codelineno-6-8" id="__codelineno-6-8" name="__codelineno-6-8"></a><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">all</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span>
</span><span id="__span-6-9"><a href="#__codelineno-6-9" id="__codelineno-6-9" name="__codelineno-6-9"></a><span class="mi">5</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">all</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
</span><span id="__span-6-10"><a href="#__codelineno-6-10" id="__codelineno-6-10" name="__codelineno-6-10"></a><span class="mi">5</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">all</span><span class="err">{</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
</span><span id="__span-6-11"><a href="#__codelineno-6-11" id="__codelineno-6-11" name="__codelineno-6-11"></a><span class="c1">-- ( != all) = not in 但是 (=all) != in</span>
</span></code></pre></div>
</div>
</div>
<div class="card">
<div class="card-header">join(连接)</div>
<div class="card-body">
<p>Join 语句的基本功能是将两张表中的 tuple 按一定规则进行匹配，将他们相同的列保留其一，不同的列全部保留，合成一个大 tuple。</p>
<ul>
<li>
<p><strong>Join Conditions ：控制哪一些列或条件用于匹配两张表中的 tuple</strong></p>
<ul>
<li>
<p>natural ： tuple 所有同名列的值相等(默认)</p>
</li>
<li>
<p>using (A1, A2...)： tuple 同名列中指定的部分列的值相等</p>
</li>
<li>
<p>on <predicate>：按照特定的规则匹配，不限于同名列</predicate></p>
</li>
</ul>
</li>
<li>
<p><strong>Join Types ：控制如何处理没有匹配对象的 tuple</strong></p>
<ul>
<li>
<p>Inner Join ：没有匹配对象则不返回(默认)</p>
</li>
<li>
<p>Left Outer Join ：左侧表的 tuple 没有匹配对象，则为扩展的列填入 NULL ，一起返回</p>
</li>
<li>
<p>Right Outer Join ：右侧表的 tuple 没有匹配对象，则为扩展的列填入 NULL ，一起返回</p>
</li>
<li>
<p>Full Outer Join ：上面二者的并集</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="card">
<div class="card-header">with/view</div>
<div class="card-body">
<p>建立一个作用域为一条语句的临时的表用于简化逻辑表达式增加可读性。相当于关系代数中的赋值操作。</p>
<div class="language-SQL highlight"><pre><span></span><code><span id="__span-7-1"><a href="#__codelineno-7-1" id="__codelineno-7-1" name="__codelineno-7-1"></a><span class="k">with</span><span class="w"> </span><span class="n">temp_table_name</span><span class="p">(</span><span class="n">attribute_name1</span><span class="p">,</span><span class="w"> </span><span class="n">attibute_name2</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">alias</span>
</span></code></pre></div>
<p>view 一般用于查找以及接口，语法和 with 相同，作用也基本相同。唯一的区别是 view 一经定义则一直可用，而 with 的作用域仅有单条语句。</p>
<details class="note">
<summary>view的特性</summary>
<ul>
<li>
<p>view 并不是实际存在的表，每次调用 view 时只是重复调用了筛选的条件。因此 update table 后，与之关联的 view 也会改变。</p>
</li>
<li>
<p>我们一般不对 view 进行 update。大部分 SQL 系统对 update view 有严格的限制。</p>
<p><img alt="sql_restrictions_on_view" src="../images/DB/db22.png"/></p>
</li>
<li>
<p>部分 SQL 也支持 materialize view ， view 此时是一张真实存在的表，这一般是为了用空间换时间。物化视图相关的表发生变化时，它自己也必须同时更新，以维持一般 view 的特性。</p>
</li>
</ul>
</details>
</div>
</div>
<div class="card">
<div class="card-header">index</div>
<div class="card-body">
<p><div class="language-sql highlight"><pre><span></span><code><span id="__span-8-1"><a href="#__codelineno-8-1" id="__codelineno-8-1" name="__codelineno-8-1"></a><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">.....);</span><span class="w"> </span><span class="c1">-- 创建</span>
</span><span id="__span-8-2"><a href="#__codelineno-8-2" id="__codelineno-8-2" name="__codelineno-8-2"></a><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 删除</span>
</span></code></pre></div>
索引的原理类似于书的目录，要查找某个词不需要从头开始阅读书籍，可以从目录查到页码直接跳转，于是加快了查找的速度。具体实现请见<a href="#indexing">#索引(indexing)</a>一节。一个表可以创建多个索引，一
个索引可以包含多个列。</p>
<p>但索引并不是尽善尽美，例如 update 之后，索引需要同步维护；同时索引是一种物理结构，有额外的空间与 IO 开销。不适当的索引设置反而会降低效率。</p>
</div>
</div>
<div class="card">
<div class="card-header">权限授予与收回</div>
<div class="card-body">
<p>授予/收回权限的基本语法是：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-9-1"><a href="#__codelineno-9-1" id="__codelineno-9-1" name="__codelineno-9-1"></a><span class="k">grant</span><span class="w"> </span><span class="o">&lt;</span><span class="n">priviledge</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="n">name</span><span class="o">&gt;</span>
</span><span id="__span-9-2"><a href="#__codelineno-9-2" id="__codelineno-9-2" name="__codelineno-9-2"></a><span class="k">on</span><span class="w"> </span><span class="o">&lt;</span><span class="n">relation_name</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">view_name</span><span class="o">&gt;</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="o">&lt;</span><span class="k">user</span><span class="w"> </span><span class="n">list</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 授予</span>
</span><span id="__span-9-3"><a href="#__codelineno-9-3" id="__codelineno-9-3" name="__codelineno-9-3"></a><span class="k">revoke</span><span class="w"> </span><span class="o">&lt;</span><span class="n">priviledge</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="n">name</span><span class="o">&gt;</span>
</span><span id="__span-9-4"><a href="#__codelineno-9-4" id="__codelineno-9-4" name="__codelineno-9-4"></a><span class="k">on</span><span class="w"> </span><span class="o">&lt;</span><span class="n">relation_name</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">view_name</span><span class="o">&gt;</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="o">&lt;</span><span class="k">user</span><span class="w"> </span><span class="n">list</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 收回</span>
</span></code></pre></div>
<p>需要注意：</p>
<ul>
<li>
<p>权限可以来自多个上级用户，相互可以重叠，例如有两者都为第三方授予了读取权限，此时即使有一方撤回了权限，第三方仍然可以正常读取。</p>
</li>
<li>
<p>权限可以级联下放，例如 A 为 B 授予了某些权限， B 可以继续向其他人授予不高于他自己的权限。当 A 撤回对 B 的权限时， B 下放给他人的权限也会同时被收回。</p>
</li>
<li>
<p>权限的基本单位是 relation ，需要授予某个数据库内所有 relation 的权限时可以使用<code>DB_name.*</code>。</p>
</li>
</ul>
<p>有多个同类用户需要做统一的权限调整时，列出<user list="">的使用方式显然不便，此时就需要 role。role 是权限组成的集合，你可以像赋予单个权限一样将 role 赋予用户。修改某个 role 对应的权限集合时，所有被赋予这个 role 身份的用户权限都会同时被修改。</user></p>
</div>
</div>
<h3 id="sql_4">高级 SQL<a class="headerlink" href="#sql_4" title="Permanent link">¶</a></h3>
<h4 id="sql_5">在高级编程语言中使用 SQL<a class="headerlink" href="#sql_5" title="Permanent link">¶</a></h4>
<p><strong>嵌入式 SQL(Embedded SQL)</strong></p>
<p>SQL 标准定义了如何将 SQL 嵌入到多种编程语言中，例如 C、Java 和 Cobol。</p>
<p>一种用来嵌入 SQL 查询的语言被称为<strong>宿主语言 (host language)</strong>，而宿主语言中允许的 SQL 结构则构成了<strong>嵌入式 SQL (embedded SQL)</strong>。</p>
<p>这些语言的基本形式遵循了 System R 将 SQL 嵌入到 PL/I 的模式:</p>
<div class="card">
<div class="card-body">
<p>嵌入式 SQL 需要解决的问题有：</p>
<ul>
<li>在宿主语言和 SQL 语句之间交换参数和结果。</li>
<li>处理集合(sets)与变量(variables)之间的差异。</li>
<li>获取 SQL 语句的执行状态。</li>
<li>将代码编译成宿主语言。</li>
</ul>
<p><strong>(1) 预处理器机制</strong></p>
<ul>
<li>
<p>输入：混合了宿主语言代码和特殊标记的 SQL 语句(通过<code>EXEC SQL</code>界定)。</p>
</li>
<li>
<p>输出：</p>
<ul>
<li>
<p>纯宿主语言代码(替换 SQL 为 PL/I 的数据库调用，如 SQLFetch)。</p>
</li>
<li>
<p>自动生成的通信区(如 SQLCA)用于传递执行状态(如错误码)。</p>
</li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">具体形式因语言而异(例如， Java 的嵌入式 SQL 使用 <code>#SQL { ... };</code>)。</p>
</div>
<p><strong>(2) 宿主变量(Host Variables)</strong></p>
<ul>
<li>
<p>作用：在 PL/I 和 SQL 间传递数据。</p>
</li>
<li>
<p>语法：宿主语言变量前加冒号(如 <code>:credit_amount</code>)，预处理器自动生成类型转换代码。</p>
</li>
<li>
<p>限制：需显式声明类型匹配(如 PL/I 的 FIXED BINARY(31) 对应 SQL 的 INTEGER)。</p>
</li>
</ul>
<p><strong>(3) 游标(cursor)</strong></p>
<p>我们知道， SQL 的查询操作返回一个元组集合，即多行数据，但是宿主语言往往只能一行一行地处理数据。所以我们需要一个东西来暂存返回的结果。我们在嵌入式 SQL 里就可以声明一个<strong>游标</strong>：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-10-1"><a href="#__codelineno-10-1" id="__codelineno-10-1" name="__codelineno-10-1"></a><span class="k">EXEC</span><span class="w"> </span><span class="k">SQL</span><span class="w"> </span><span class="k">DECLARE</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="k">CURSOR</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span>
</span><span id="__span-10-2"><a href="#__codelineno-10-2" id="__codelineno-10-2" name="__codelineno-10-2"></a><span class="w">  </span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">dept_var</span><span class="p">;</span>
</span><span id="__span-10-3"><a href="#__codelineno-10-3" id="__codelineno-10-3" name="__codelineno-10-3"></a><span class="n">END_EXEC</span><span class="p">;</span>
</span></code></pre></div>
<p>这样，在数据库端创建一个临时工作区，存储查询结果(避免一次性传输大量数据到客户端)。同时，通过游标位置，宿主语言也可以逐行访问结果。</p>
<p><strong>操作流程</strong>：</p>
<ul>
<li>
<p><code>OPEN cur</code>：执行查询，创建临时结果集；</p>
</li>
<li>
<p><code>FETCH cur INTO :id, :name</code>：获取单行数据到宿主变量。如果需要连续获取需要考虑循环；</p>
</li>
<li>
<p><code>CLOSE cur</code>：关闭查询，释放资源。</p>
</li>
</ul>
<p><strong>错误检查</strong>：</p>
<p>SQLCA(SQL Communication Area)：</p>
<ul>
<li>
<p>包含 SQLSTATE(如 '02000' 表示无更多数据)。</p>
</li>
<li>
<p>宿主语言通过检查 SQLCA 判断 SQL 执行状态。</p>
</li>
</ul>
</div>
</div>
<p><strong>示例</strong>：学生学分查询(通过游标逐行处理结果)。</p>
<div class="language-C highlight"><pre><span></span><code><span id="__span-11-1"><a href="#__codelineno-11-1" id="__codelineno-11-1" name="__codelineno-11-1"></a><span class="kt">void</span><span class="w"> </span><span class="nf">getStudentInfo</span><span class="p">()</span>
</span><span id="__span-11-2"><a href="#__codelineno-11-2" id="__codelineno-11-2" name="__codelineno-11-2"></a><span class="p">{</span>
</span><span id="__span-11-3"><a href="#__codelineno-11-3" id="__codelineno-11-3" name="__codelineno-11-3"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">credit_amount</span><span class="p">;</span>
</span><span id="__span-11-4"><a href="#__codelineno-11-4" id="__codelineno-11-4" name="__codelineno-11-4"></a><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">sId</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span id="__span-11-5"><a href="#__codelineno-11-5" id="__codelineno-11-5" name="__codelineno-11-5"></a><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">sName</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span id="__span-11-6"><a href="#__codelineno-11-6" id="__codelineno-11-6" name="__codelineno-11-6"></a><span class="w">    </span><span class="n">EXEC</span><span class="w"> </span><span class="n">SQL</span><span class="w"> </span><span class="n">declare</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">cursor</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">tot_cred</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="n">credit_amount</span><span class="w"> </span><span class="n">END</span><span class="w"> </span><span class="n">EXEC</span><span class="p">;</span>
</span><span id="__span-11-7"><a href="#__codelineno-11-7" id="__codelineno-11-7" name="__codelineno-11-7"></a><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"Please input the credit amount: "</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-11-8"><a href="#__codelineno-11-8" id="__codelineno-11-8" name="__codelineno-11-8"></a><span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">credit_amount</span><span class="p">);</span>
</span><span id="__span-11-9"><a href="#__codelineno-11-9" id="__codelineno-11-9" name="__codelineno-11-9"></a><span class="w">    </span><span class="n">EXEC</span><span class="w"> </span><span class="n">SQL</span><span class="w"> </span><span class="n">open</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">END_EXEC</span><span class="p">;</span>
</span><span id="__span-11-10"><a href="#__codelineno-11-10" id="__codelineno-11-10" name="__codelineno-11-10"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span id="__span-11-11"><a href="#__codelineno-11-11" id="__codelineno-11-11" name="__codelineno-11-11"></a><span class="w">    </span><span class="p">{</span>
</span><span id="__span-11-12"><a href="#__codelineno-11-12" id="__codelineno-11-12" name="__codelineno-11-12"></a><span class="w">        </span><span class="n">EXEC</span><span class="w"> </span><span class="n">SQL</span><span class="w"> </span><span class="n">fetch</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="o">:</span><span class="n">sId</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="n">sName</span><span class="w"> </span><span class="n">END_EXEC</span><span class="p">;</span>
</span><span id="__span-11-13"><a href="#__codelineno-11-13" id="__codelineno-11-13" name="__codelineno-11-13"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">SQLSTATE</span><span class="p">,</span><span class="s">"02000"</span><span class="p">))</span><span class="w"> </span><span class="c1">// 02000状态码表示表中已经没有数据</span>
</span><span id="__span-11-14"><a href="#__codelineno-11-14" id="__codelineno-11-14" name="__codelineno-11-14"></a><span class="w">            </span><span class="k">break</span><span class="p">;</span>
</span><span id="__span-11-15"><a href="#__codelineno-11-15" id="__codelineno-11-15" name="__codelineno-11-15"></a><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"%s %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">sId</span><span class="p">,</span><span class="n">sName</span><span class="p">);</span>
</span><span id="__span-11-16"><a href="#__codelineno-11-16" id="__codelineno-11-16" name="__codelineno-11-16"></a><span class="w">    </span><span class="p">}</span>
</span><span id="__span-11-17"><a href="#__codelineno-11-17" id="__codelineno-11-17" name="__codelineno-11-17"></a><span class="w">    </span><span class="n">EXEC</span><span class="w"> </span><span class="n">SQL</span><span class="w"> </span><span class="n">close</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">END_EXEC</span><span class="p">;</span>
</span><span id="__span-11-18"><a href="#__codelineno-11-18" id="__codelineno-11-18" name="__codelineno-11-18"></a><span class="p">}</span>
</span></code></pre></div>
<p><strong>ODBC 与 JDBC</strong></p>
<p>它们都是实现程序与数据库交互的 API(application-program interface)。</p>
<p><strong>ODBC</strong>是 C/C#/C++/VB 的通用 API ，通过驱动管理器连接数据库(配置 DSN)。</p>
<p>核心函数：<code>SQLConnect()</code>, <code>SQLExecDirect()</code>, <code>SQLFetch()</code>。</p>
<p>安全风险： SQL 注入(需用预编译语句 SQLPrepare)。</p>
<h4 id="_3">过程化扩展<a class="headerlink" href="#_3" title="Permanent link">¶</a></h4>
<h4 id="trigger">触发器(Trigger)<a class="headerlink" href="#trigger" title="Permanent link">¶</a></h4>
<h4 id="olap">高级聚合与 OLAP<a class="headerlink" href="#olap" title="Permanent link">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>好像不考，我就不写了(</p>
</div>
<h2 id="_4">数据库设计范式<a class="headerlink" href="#_4" title="Permanent link">¶</a></h2>
<h3 id="e-r">E-R 模型<a class="headerlink" href="#e-r" title="Permanent link">¶</a></h3>
<h4 id="_5">模型概念<a class="headerlink" href="#_5" title="Permanent link">¶</a></h4>
<ul>
<li>
<p>实体(entity)：在现实世界中能够与其他对象区分开来的一个对象．</p>
<p>一个实体会有一组属性(attribute)，我们可以用某些属性的值来识别唯一的实体．</p>
<p>实体可以是具体的，也可以是抽象的．</p>
</li>
<li>
<p>实体集(entity set)：相同类型（共享相同的属性）的一组实体构成了一个实体集．</p>
<p>ER 图中实体集的表示：用矩形表示实体集．矩形被分为两部分，上半部分是实体集的名字，下半部分包含了所有属性的名称，其中作为主键的属性用下划线表示．</p>
<p><div align="center"> <br>
<img alt="perform_1" src="../images/DB/db41.png" style="zoom: 90%"/>
</br></div></p>
</li>
</ul>
<p><strong>联系(relationship)</strong>是多个（两个及以上）实体的关联．</p>
<p><strong>联系集(relationship set)</strong>：一组相同类型的关系．</p>
<div class="language-text highlight"><pre><span></span><code>- 大多数关系集都是二元的，但有时也存在三元甚至包含更多实体集的关系．我们称参与到某个关系集的实体集个数为该关系集的**度(degree)**．

- 联系集的形式化定义：设 $n$ 个可重复的实体集分别为 $E_1, E_2, ..., E_n$，在他们之上定义的联系集是一个关系(relation)，且应该是 $\{ (e_1, e_2, ..., e_n) \mid e_1 \in E_1, e_2 \in E_2, ..., e_n \in E_n \}$ 的子集。$(e_1, e_2, ..., e_n)$ 称为联系的一个实例。

- 一组特性的实体集之间可能会包含多个联系集。

ER 图中关系集的表示：用菱形(diamond)表示关系集，并从这个菱形出发，通过 直线(line) 连接到参与该关系集的实体集．

&lt;div align="center"&gt;    
&lt;img src="../images/DB/db42.png" alt="perform_2" style="zoom: 80%"/&gt;
&lt;/div&gt;
</code></pre></div>
<div align="center">
<img alt="ER_1" src="../images/DB/db29.png" style="zoom: 90%"/>
</div>
<div align="center">
<img alt="ER_2" src="../images/DB/db30.png" style="zoom: 90%"/>
</div>
<h2 id="_6">存储<a class="headerlink" href="#_6" title="Permanent link">¶</a></h2>
<h3 id="_7">存储层级<a class="headerlink" href="#_7" title="Permanent link">¶</a></h3>
<p><img alt="storage" src="../images/DB/db2.png"/></p>
<p>上图中的是否易失是根据掉电后数据会不会丢失区分的。</p>
<h3 id="_8">磁盘存储接口<a class="headerlink" href="#_8" title="Permanent link">¶</a></h3>
<p>存储设备通常直接连接到计算机系统上，因此往往需要一个接口。目前一些主流的存储设备协议家族有：</p>
<ul>
<li>
<p>SATA</p>
<p>最近的 SATA 3 理论带宽可以达到 6Gbps。</p>
</li>
<li>
<p>SAS</p>
<p>第三代 SAS 理论带宽可达 12Gbps ，第四代的理论带宽可达 22.5Gbps。</p>
</li>
<li>
<p>NVMe</p>
<p>是一种直接运行在 PCIe 总线上的高效协议。它通过 PCIe 接口访问非易失性数据，延迟更小，传输速度更快。
NVMe 2.0 采用 PCIe 5.0 x4 接口，理论带宽可达约 16GB/s。</p>
</li>
</ul>
<p>我们也时不时需要在网络上存储数据。<strong>SAN</strong> 和 <strong>NAS</strong> 就是两种主流的网络存储架构。</p>
<ul>
<li>
<p><strong>SAN(Storage Area Networks ，存储区域网络)</strong></p>
<p>A large number of disks are connected by a high-speed network to a number of servers.</p>
</li>
<li>
<p><strong>NAS(Network Attached Storage ，网络附加存储)</strong></p>
<p>Networked storage provides a file system interface using networked file system protocol, instead of providing a disk system interface.</p>
</li>
</ul>
<h3 id="_9">磁盘工作机制<a class="headerlink" href="#_9" title="Permanent link">¶</a></h3>
<p>下图展示一个机械硬盘的结构：</p>
<p><img alt="disk_mechanism" src="../images/DB/db3.png"/></p>
<ol>
<li>
<p><strong>读写磁头 (Read-write head)</strong></p>
<ul>
<li>
<p>定位在盘片表面极近处(几乎接触)</p>
</li>
<li>
<p>通过磁编码方式读取/写入信息  </p>
</li>
</ul>
<p><em>技术说明：现代硬盘采用气浮技术保持 3-10 纳米间距，称为"飞行高度"(Flying Height)</em></p>
</li>
<li>
<p>盘片表面划分 </p>
<ul>
<li>
<p>由同心圆状的<strong>磁道(Track)</strong>组成  </p>
</li>
<li>
<p>典型硬盘每盘片含 50,000-100,000 条磁道  </p>
</li>
</ul>
<p><em>注：磁道密度随技术发展提升， HAMR(热辅助磁记录)技术可达 200k+TPI(每英寸磁道数)</em></p>
</li>
<li>
<p>磁道结构 </p>
<ul>
<li>
<p>每条磁道划分为<strong>扇区(Sector)</strong> </p>
</li>
<li>
<p>扇区是物理读写的最小数据单元  </p>
</li>
<li>
<p>典型扇区大小： 512 字节(现代高级格式盘为 4K)  </p>
</li>
<li>
<p>每磁道扇区数：<br>
    内圈磁道： 500-1000 个<br/>
    外圈磁道： 1000-2000 个  </br></p>
</li>
</ul>
<p><em>技术演进： ZBR(区位记录)技术使外圈磁道存储更多扇区</em></p>
</li>
<li>
<p>扇区访问机制</p>
<ul>
<li>
<p>磁臂摆动使磁头定位到目标磁道  </p>
</li>
<li>
<p>盘片持续旋转，当扇区经过磁头下方时完成读写  </p>
</li>
</ul>
<p><em>延迟组成：寻道时间(Seek Time) + 旋转延迟(Rotational Latency)</em></p>
</li>
<li>
<p><strong>磁头-盘片组件(Head-Disk Assembly, HDA)</strong></p>
<ul>
<li>
<p>单个主轴安装多层盘片(通常 1-5 片)  </p>
</li>
<li>
<p>每个盘面对应一个磁头，所有磁头安装在同一磁臂上  </p>
</li>
</ul>
<p><em>关键参数：面密度(Areal Density) = 磁道密度 × 线性密度</em></p>
</li>
<li>
<p><strong>柱面(Cylinder)</strong> </p>
<ul>
<li>由所有盘片的第 <span class="arithmatex">\(i\)</span> 号磁道组成柱面 <span class="arithmatex">\(i\)</span> </li>
</ul>
<p><em>优化原理：同一柱面数据无需移动磁臂即可连续访问</em></p>
</li>
</ol>
<p>有了主机系统和存储设备，我们还需要一个主机系统与物理存储设备之间的桥梁来实现管理和优化数据存取。<strong>磁盘管理器(Disk Controller)</strong>就担当了这一角色。</p>
<p>磁盘管理器：</p>
<ul>
<li>
<p>接收高层读写扇区指令 (解析来自操作系统的读/写扇区命令)</p>
</li>
<li>
<p>启动磁盘操作：例如驱动磁头移动到指定磁道、执行物理层面的数据读写操作等</p>
</li>
<li>
<p>数据校验管理：为每个扇区计算并附加<strong>校验和(checksums)</strong> (如 CRC32/ECC)，读取时通过校验和验证数据完整性</p>
<ul>
<li>错误检测机制：当数据损坏时，存储的校验和与重新计算值不匹配的概率极高</li>
</ul>
</li>
<li>
<p>写入验证：采用“写后读”(Read-After-Write)技术确保写入成功</p>
</li>
<li>
<p>坏扇区处理：执行坏扇区重映射 (remapping of bad sectors ，通过备用扇区替换损坏区域)</p>
</li>
</ul>
<h3 id="_10">磁盘性能评估<a class="headerlink" href="#_10" title="Permanent link">¶</a></h3>
<p>磁盘性能一般从以下维度评价：</p>
<ul>
<li>
<p>Access time 访问时间</p>
<p>对 HDD 又可以细分为 Seek time 寻道时间 和 Rotation latency 旋转延迟。</p>
</li>
<li>
<p>Data-transfer rate 数据传输速率</p>
</li>
<li>
<p>IOPS 每秒 I/O 操作数</p>
</li>
<li>
<p>Mean time of failure(MTTF) 平均故障时间</p>
</li>
</ul>
<p>根据所访问数据的储存位置，可以将访问分为随机访问 (Random access)和顺序访问 (Sequential access)。顺序访问的上限主要由传输速率决定；随机访问的上限主要由 IOPS 决定， IOPS 又主要由访问时间决定。</p>
<p>优化磁盘性能的常见方式主要有：</p>
<ul>
<li>
<p>Buffering 缓冲区，避免重复读写相同数据</p>
</li>
<li>
<p>Read-ahead 预读取</p>
</li>
<li>
<p>Disk-arm-scheduling ：针对 HDD ，相比让磁头来回摇摆，适当重排 IO 请求使磁头有序移动能减少平均寻道时间</p>
<div class="admonition 电梯算法">
<p class="admonition-title">电梯算法</p>
</div>
</li>
<li>
<p>File Organization ：针对 HDD ，文件整理，使数据分布尽可能有序</p>
</li>
<li>
<p>Wear Leveling ：针对 NVM 和 SSD ，因为擦写寿命相对有限，需要实现负载均衡</p>
</li>
</ul>
<h3 id="flash-storage">闪存 Flash Storage<a class="headerlink" href="#flash-storage" title="Permanent link">¶</a></h3>
<h2 id="_11">数据存储结构<a class="headerlink" href="#_11" title="Permanent link">¶</a></h2>
<p>从物理存储的层面上看，一个数据库由多个文件(files)组成，每个文件是记录(records)的有序序列，每条记录是字段(fields)的有序序列。</p>
<p>由于扇区的空间比较小且数目众多，在寻址时比较困难，所以操作系统就将多个扇区组合在一起，形成一个更大的单位，再对这个单位进行整体的操作。一般将这个单位称作<strong>块(blocks)</strong>。也就是说，操作系统是通过块来做为单位读取等操作数据的。而文件系统就是操作系统的一部分，<u>所以文件系统操作文件的最小单位是块</u>。</p>
<p>我们下面的讨论假设每条记录的大小都不超过一个块。</p>
<h3 id="_12">单条记录<a class="headerlink" href="#_12" title="Permanent link">¶</a></h3>
<h4 id="_13">定长记录存储<a class="headerlink" href="#_13" title="Permanent link">¶</a></h4>
<p>按行存放 (Row-Oriented Storage) 的定长数据的增查改都容易实现：</p>
<ul>
<li>
<p>Store record i starting from byte <span class="arithmatex">\(n * (i – 1)\)</span>, where <span class="arithmatex">\(n\)</span> is the size of each record.</p>
</li>
<li>
<p>访问数据是简单的，但是一条记录可能跨块存储。于是我们做出限定：记录不允许跨越块的边界。</p>
</li>
</ul>
<p>删除一般有两种方式：</p>
<ul>
<li>
<p>删除后的空位用链表串联供下次插入用 (如图所示： link all free records on a free list)</p>
<p><img alt="file_deletion_1" src="../images/DB/db4.png"/></p>
</li>
<li>
<p>删除后将最下面的一个数据移到删除后的空位</p>
</li>
</ul>
<p>但是数据还可以按列存放，称为 Columnar Representation 或 Column-Oriented Storage 。增删查改的实现与上面类似；按列存放更有利于向量运算。如果按属性访问多于按 tuple 访问，这种储存方式会更快。</p>
<h4 id="_14">不定长记录存储<a class="headerlink" href="#_14" title="Permanent link">¶</a></h4>
<details class="tip">
<summary>为什么会有变长记录</summary>
<ul>
<li>
<p>多记录类型共存：单文件存储不同结构记录(如 PostgreSQL 的 TOAST 机制)</p>
</li>
<li>
<p>变长字段： VARCHAR、TEXT、BLOB 等类型</p>
</li>
<li>
<p>重复字段：历史数据模型(如网状/层次模型)允许的多值属性</p>
</li>
</ul>
<p>例如，存储 JSON 数组时可能产生变长记录</p>
</details>
<p>用 null-bit map 解决允许为 NULL 的数据储存。n 个允许为空的属性需要 n 个 bit 的空位图，空位图中某一 bit 为 0/1 意味着对应的属性不是/是空的。</p>
<blockquote>
<p>需要注意的是 memory 不允许以 bit 为单位的读写， n 不能被 8 整除时需要补齐到 8 的整倍数 (至少 1Byte) 以实现 Byte 为单位的读写。</p>
</blockquote>
<p>属性按照顺序存储。对于不定长的属性值，用定长的数据 <span class="arithmatex">\(\mbox{(offset, length)}\)</span> 间接表达，例如图中(21, 5)表示该属性从 21 号 Byte 开始且长度为 5。
在定长的属性值存储完后再存储不定长属性值的本体。</p>
<p><img alt="file_deletion_2" src="../images/DB/db5.png"/></p>
<h3 id="slotted-page">槽式页(Slotted Page)<a class="headerlink" href="#slotted-page" title="Permanent link">¶</a></h3>
<p><strong>Slotted Page(槽式页)</strong> 是数据库系统中用于组织磁盘数据页的一种高效结构，特别适用于管理变长记录。</p>
<p>不定长数据的数据页一般采用两头夹击的结构便于对齐。</p>
<ul>
<li>
<p>页头(Header)设计</p>
<ul>
<li>
<p>记录条目数：维护当前页内有效记录数(如 PostgreSQL 的<code>pd_lowe</code>)</p>
</li>
<li>
<p>空闲空间尾指针：指向可用空间起始位置(如 MySQL 的<code>PAGE_FREE</code>)</p>
</li>
<li>
<p>记录位置/大小数组：每个槽位存储(offset, length)二元组</p>
</li>
</ul>
</li>
<li>
<p>记录移动策略</p>
<p>数据页可以通过移动记录消除碎片，保持数据的连续性。</p>
<p>但是需要注意，所有的相关指针必须同步原子性更新，否则会破坏数据的一致性。</p>
</li>
<li>
<p>指针间接访问。外部指针指向页头中指向实际数据的指针(二级指针)。</p>
</li>
</ul>
<pre class="mermaid"><code>graph LR
A[外部指针] --&gt; B[槽数组条目]
B --&gt; C[实际记录位置]</code></pre>
<h3 id="_15">文件记录组织<a class="headerlink" href="#_15" title="Permanent link">¶</a></h3>
<p>我们总需要一种方式组织单条数据和数据页，即它们如何分布在文件内部。下图是几种常见的结构：</p>
<p><img alt="File_Organization" src="../images/DB/db6.png"/></p>
<h4 id="heap">堆(Heap)文件管理<a class="headerlink" href="#heap" title="Permanent link">¶</a></h4>
<p>堆文件的<strong>特性</strong>有：</p>
<ul>
<li>
<p>记录自由放置：记录可以插入到文件中任何有空闲空间的位置</p>
</li>
<li>
<p>记录固定性：记录一旦写入通常不移动(除非主动重组)</p>
</li>
<li>
<p>关键需求：需要高效定位空闲空间</p>
</li>
</ul>
<p>我们可以采用<strong>空闲空间映射表(Free-Space Map, FSM)</strong>来快速定位有足够空闲空间的块。</p>
<ul>
<li>
<p>对于一级 FSM ，每个块对应一个条目(1 entry per block)。每一个条目都用数位(一般最多到一个字节)来记录对应块中空余空间的比例。</p>
</li>
<li>
<p>我们来看一个例子：</p>
<details class="example">
<summary>Example</summary>
<p>在这个例子中，每个条目我们用 3 位，条目值除以 8 (<span class="arithmatex">\(2^3\)</span>) 的值就是块中剩余空间的比例。</p>
<p>我们还可以采取二级 FSM 的方式加速大范围空闲块搜索。比如，对于这个示例，我们让每个二级条目对应 4 个一级条目，存储这 4 个块中的最大空闲比例。</p>
</details>
</li>
<li>
<p>FSM 会定期写入(非实时更新)磁盘，容忍暂时性不一致，这种暂时性的不一致会被检测并修复。通常采取的检测方式是，在实际分配时再次验证可用空间。</p>
</li>
</ul>
<h4 id="sequential">顺序(Sequential)文件管理<a class="headerlink" href="#sequential" title="Permanent link">¶</a></h4>
<p>这里的 Sequential 不是指储存空间上有序，而是指每一条数据逻辑关系上有序。在数据经常按某种排序先后取用时，可以考虑顺序文件系统。先后逻辑一般用类似指针的结构实现。</p>
<ul>
<li>
<p>删除：使用指针链。改变指针指向以改变逻辑先后关系。空余位置的处理视单条数据的结构而定。</p>
</li>
<li>
<p>插入：需要先定位记录在何处插入。有剩余空间可以直接插入。但是如果当前 block 满了，只能插入到新 block 中(<strong>overflow block</strong>)。但我们又需要维持逻辑先后关系，这时就会形成下图所示的结构(为便于理解这里以定长数据为例)。</p>
<p><img alt="overflow_block" src="../images/DB/db7.png"/></p>
</li>
</ul>
<p>因为存在上图所示问题，在多次插入和删除之后指针系统会变得很低效，因此顺序文件系统需要适时 Reorganize。</p>
<h4 id="multitable-clustering">多表聚簇(Multitable Clustering)文件管理<a class="headerlink" href="#multitable-clustering" title="Permanent link">¶</a></h4>
<p>这种技术将多个逻辑上关联的表的记录混合存储在同一个物理文件块中，以优化关联查询性能。从实现上看，它是将频繁参与连接操作(如<code>JOIN</code>)的表记录存储在同一物理页或相邻页中。下面就是一个例子：</p>
<p><img alt="example_of_mul_clus" src="../images/DB/db8.png"/></p>
<p>这可以提高查找的速度，但也意味着成倍的空间和增删改成本。</p>
<p>优势：</p>
<p>✅ 关联查询性能提升</p>
<p>✅ 减少连接操作的 CPU 开销</p>
<p>✅ 提高缓存局部性(相关数据同处 CPU 缓存行)</p>
<p>局限：</p>
<p>❌ 非关联查询可能变慢(如全表扫描单表)</p>
<p>❌ 插入/更新开销增加(需维护共置关系)</p>
<p>❌ 设计复杂度高(需预知查询模式)</p>
<p>我们也可以利用指针连接起一些关系的记录：</p>
<p><img alt="pointer_mul_clus" src="../images/DB/db9.png"/></p>
<h4 id="table-partitioning">Table Partitioning<a class="headerlink" href="#table-partitioning" title="Permanent link">¶</a></h4>
<p>一个关系里的有些记录可以被分成一些更小的记录分别储存。</p>
<p>例如选课信息表，虽然从逻辑上所有学年的选课信息都在同一张表上，但是因为往年的数据几乎不需要增删查改，数据操作集中于当前学年，所以按照学年物理划分为多个储存文件将有助于提高性能。</p>
<h4 id="b-tree-file-index">B+ Tree File Index<a class="headerlink" href="#b-tree-file-index" title="Permanent link">¶</a></h4>
<p>B+树不仅可以作为索引的结构，还可以直接作为文件组织的结构。在下一章“索引”中会进行介绍。</p>
<h3 id="data-dictionary-storage">数据字典存储(Data Dictionary Storage)<a class="headerlink" href="#data-dictionary-storage" title="Permanent link">¶</a></h3>
<p>上面的三类文件组织都是对库中的实例而言的，但是数据库还有一些框架性的全局的信息需要储存，我们称为<strong>Metadata</strong>。<strong>Data Dictionary</strong>(亦称<strong>system catalog</strong>)就用来存储这些信息。</p>
<p><img alt="data_dic_storage" src="../images/DB/db10.png"/></p>
<p>其中一种实现方式是用事先约定的固定的几个表，储存用户定义的信息。在磁盘中，这些 metadata 可以用下面的关系图表示：</p>
<p><img alt="data_dic_storage_relation" src="../images/DB/db11.png"/></p>
<h3 id="_16">缓冲区/缓存<a class="headerlink" href="#_16" title="Permanent link">¶</a></h3>
<p>我们希望更快速地获取一些短时间内频繁使用的数据。<strong>缓冲区(Buffer)</strong>就是这样的角色。Buffer 是主内存中用于存储磁盘块副本的专用区域。而<strong>缓冲区管理器(Buffer Manager)</strong>就是负责动态分配和管理内存缓冲区的核心子系统。</p>
<p>程序进程需要缓冲区中的数据时，它们就会唤起缓冲区管理器。</p>
<p>若该块已在缓冲区中，缓冲区管理器返回其在主内存中的地址。  </p>
<p>若该块不在缓冲区中，缓冲区管理器则：  </p>
<ol>
<li>
<p>在缓冲区内为该块分配空间  </p>
</li>
<li>
<p>如有必要，置换(移出)其他块以腾出空间  </p>
<ul>
<li>仅当被置换块自上次磁盘读写后被修改过，才将其写回磁盘  </li>
</ul>
</li>
<li>
<p>将目标块从磁盘读入缓冲区，并向请求者返回其主内存地址</p>
</li>
</ol>
<p>最常用的是 LRU 策略(Least Recently Used Stratergy)，即根据“最近访问过的内容更有可能再次被访问”的原则管理缓存内容。需要理解下图所示 buffer 的变化(实际上这部分内容计组也涉及过)：</p>
<p><img alt="buffer_change" src="../images/DB/db12.png"/></p>
<p>其余缓存策略：</p>
<p><img alt="other_buffer_rep_policy" src="../images/DB/db13.png"/></p>
<h2 id="indexing">索引(Indexing)<a id="indexing"></a><a class="headerlink" href="#indexing" title="Permanent link">¶</a></h2>
<p>索引机制旨在加速对目标数据的访问。我们生活中也会遇到索引，比如图书馆书目的索引。</p>
<p>一个<strong>索引文件(index file)</strong>由如下形式的记录(称为<strong>索引条目(index entries)</strong>)</p>
<p><img alt="index_form" src="../images/DB/db14.png"/></p>
<p>其中，<strong>search key(搜索键)</strong>是所有列中被选中用来查找记录的属性(列名)。这里的指针都指向各条记录。</p>
<h3 id="_17">有序索引和无序索引<a class="headerlink" href="#_17" title="Permanent link">¶</a></h3>
<p>有两种基本的索引方式：<strong>有序索引</strong>和<strong>无序索引</strong>。这里的“序”指的是 search key 的值有无顺序。</p>
<p>无序索引比较常见的是<strong>哈希索引(Hash indecies)</strong>，其原理就是通过哈希操作分布，而哈希操作想必大家在 FDS 课程中都已经有所了解。</p>
<p>顺序索引可以根据不同的排序规则分类成：</p>
<ul>
<li>
<p><strong>Primary Index (clustering index)</strong></p>
<p>索引(搜索键)的顺序与物理储存的顺序对应。</p>
<p><img alt="primary_index" src="../images/DB/db15.png"/></p>
<p><strong>Index-sequential file</strong>: ordered sequential file with a primary index.</p>
</li>
<li>
<p><strong>Secondary Index (non-clustering index)</strong></p>
<p>物理存储不按照搜索键存储。每个索引条目指向一个指针桶，这个指针桶指向相同搜索键值的所有数据。</p>
<p><img alt="secondary_index" src="../images/DB/db16.png"/></p>
</li>
</ul>
<p><u>二级索引必须是<strong>稠密(Dense)</strong>的</u>。一个稠密索引中，一条索引必须对应一个搜索键值，每个搜索键值都要有相应的索引对应。稠密索引对文件是否是顺序的没有要求。</p>
<p><img alt="secondary_dense" src="../images/DB/db17.png"/></p>
<p>在上图中，文件并没有按照索引的搜索键<code>dept_name</code>存储，所以这是一个二级索引，同时是一个稠密索引。</p>
<p>与之对应的，<strong>稀疏索引(Sparse Index)</strong>指的是只有部分搜索键值有对应索引。</p>
<p><img alt="sparse_index" src="../images/DB/db18.png"/></p>
<p>比如我们如果想找到搜索键值为 K 的记录：</p>
<ul>
<li>
<p>找到比 K 小的搜索键值中最大的那个的索引</p>
</li>
<li>
<p>从索引指向的记录开始顺序查找</p>
</li>
</ul>
<p>稀疏索引相较于稠密索引，其可以</p>
<ul>
<li>
<p>显著减少索引体积；</p>
</li>
<li>
<p>维护成本低，增删操作时一般情况下只需要更新少量索引条目。例如：块内数据变动不触发索引更新，除非涉及块的边界键值。</p>
</li>
</ul>
<p>但是，稀疏索引由于需要两步定位记录，所以整体上查询记录的效率不如稠密索引。</p>
<p>我们有一个较好的折中方案，<strong>按数据块建立稀疏索引</strong>：每个文件块(Block)在索引中对应一个条目，存储该块的最小搜索键值。</p>
<p>按照这个方案，我们可以继续嵌套下去，形成<strong>多级索引(Multilevel Index)</strong>。</p>
<h3 id="b">B+树索引<a class="headerlink" href="#b" title="Permanent link">¶</a></h3>
<p>有了前面的多级索引结构，我们或许能够联想到树的结构。于是，<strong>B+树索引</strong>作为一种顺序索引的替代出现了，并且广泛为大家所用！</p>
<p><strong>索引顺序文件的缺点</strong>：  </p>
<ul>
<li>
<p>因溢出块(overflow block)增多，其性能会随着文件增大而下降 </p>
</li>
<li>
<p>需定期重组整个文件  </p>
</li>
</ul>
<p><strong>B+树索引文件的优点</strong>：  </p>
<ul>
<li>
<p>插入/删除时可自动小幅重组  </p>
</li>
<li>
<p>多数情况下无需全文件重组即可维持性能  </p>
</li>
</ul>
<p><strong>(次要)B+树的劣势</strong>：  </p>
<ul>
<li>
<p>额外的插入/删除开销  </p>
</li>
<li>
<p>空间占用略高  </p>
</li>
</ul>
<p>但是， B+树优点远胜缺点，因而被广泛应用。下面是一个 B+树的例子：</p>
<p><img alt="example_bplus" src="../images/DB/db19.png"/></p>
<h4 id="b_1">B+树的结构<a class="headerlink" href="#b_1" title="Permanent link">¶</a></h4>
<ul>
<li>
<p>所有叶子节点深度相同。我们已经学过， n 阶高度为 h 的 B+ 树的叶子层最少有 <span class="arithmatex">\(2*(( \lceil n/2 \rceil )^{h-2}) * \lceil (n-1)/2 \rceil\)</span> 个节点，最多 <span class="arithmatex">\((n^{h-1}) * (n-1)\)</span> 个节点；</p>
</li>
<li>
<p>节点填充率：非叶子节点需满足至少有 <span class="arithmatex">\(\lceil n/2 \rceil\)</span> 到 <span class="arithmatex">\(n\)</span> 个子节点；</p>
</li>
<li>
<p>叶子节点通过指针链支持范围查询。</p>
</li>
</ul>
<h4 id="b_2">B+树索引的操作<a class="headerlink" href="#b_2" title="Permanent link">¶</a></h4>
<ul>
<li>
<p><strong>查询</strong>：从根到叶的路径搜索(复杂度 <span class="arithmatex">\(O(\log_{\lceil n/2 \rceil}K)\)</span> )</p>
</li>
<li>
<p><strong>插入/删除</strong>：可能触发节点分裂/合并，向上传播</p>
<p>插入之前先进行排序，比乱序插入更新索引的代价小，尤其对于 B+树索引而言。对 B+树，批量插入还可以直接建叶节点，然后自叶向根更新而不是从顶而下插入。</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">B+树不仅可以作为记录的索引，还可以作为文件的结构，叶节点不是指针而是记录本身即可。</p>
</div>
<p>一个页中可以存放的索引大小应该是：</p>
<div class="arithmatex">\[
单页索引个数 = \frac{页大小 - 指针大小}{索引数据大小 + 指针大小} + 1
\]</div>
<h3 id="_18">内存索引优化<a class="headerlink" href="#_18" title="Permanent link">¶</a></h3>
<p>对<strong>磁盘</strong>而言，与磁盘页大小相匹配的索引用起来更快；因为磁盘 IO 的最小单位是扇区。</p>
<p>而对<strong>memory 和 cache</strong>而言，节点大小小的用起来更快；因为随机访问性能高得多，也没有扇区大小限制。</p>
<h3 id="_19">高级索引<a class="headerlink" href="#_19" title="Permanent link">¶</a></h3>
<p><strong>多键索引</strong></p>
<p>复合搜索键都是<strong>按照字典序(Lexicographic order)来排列</strong>的。多键复合索引可以高效地支持多条件查询。</p>
<details class="danger">
<summary>字典序</summary>
<p>字典序是指: <span class="arithmatex">\((a_1, a_2) &lt; (b_1, b_2)\)</span> if either</p>
<ul>
<li>
<p><span class="arithmatex">\(a_1 &lt; b_1\)</span>, or</p>
</li>
<li>
<p><span class="arithmatex">\(a_1 = b_1\)</span> and <span class="arithmatex">\(a_2 &lt; b_2\)</span></p>
</li>
</ul>
<p>假设我们有<code>(dept_name, salary)</code>作为复合搜索键。那么，我们可以有效处理：</p>
<ul>
<li>
<p><code>where dept_name = "Finance" and salary = 80000</code></p>
</li>
<li>
<p><code>where dept_name = "Finance" and salary &lt; 80000</code></p>
</li>
</ul>
<p>而不能有效处理</p>
<ul>
<li>
<p><code>where dept_name &lt; "Finance" and balance = 80000</code></p>
<p>这会导致许多在逻辑上满足第一个条件但是不满足第二个条件的行也被选中。</p>
</li>
</ul>
</details>
<h3 id="_20">写入优化索引<a class="headerlink" href="#_20" title="Permanent link">¶</a></h3>
<ul>
<li>
<p><strong>LSM(Log Structured Merge)树</strong></p>
<p>内存缓冲(L0) + 多层磁盘合并(L1, L2...)，多级树型索引分别放在不同层次的储存上</p>
<ul>
<li>
<p>优点：写放大低(顺序 I/O)</p>
<p>保证了写入的速度(先往更快的 mem 写，攒够一定量后再一次性写入 disk)；减少了磁盘的写入量(因为磁盘 IO 的最小单位是扇区，单次大量写入对磁盘的消耗远小于多次少量写入)</p>
</li>
<li>
<p>缺点：读需查多级(要在多棵树里找)</p>
<p>如果每一层级允许同时存在多棵树，称为<strong>Setpped-merge index</strong>，这种做法进一步用编程难度、空间复杂度和查询速度换写速度。</p>
</li>
</ul>
</li>
<li>
<p><strong>缓存树(Buffer Tree)</strong></p>
<p>可以替代 LSM 树。其核心点在于，每个内部节点都有缓冲去缓冲写入操作，之后批量下推。</p>
<ul>
<li>
<p>每条记录的 I/O 操作相应减少；查询的开支也减少了。Buffer Tree 可以用于<u>任何树结构的索引</u>。</p>
</li>
<li>
<p>但是相对于 LSM 树增加了随机 I/O</p>
</li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>课程 PPT 将 B 树索引、哈希索引等一概隐藏了，这里就不放了，感兴趣的朋友可以去看教材。</p>
</div>
<hr/>
<h2 id="_21">查询处理<a class="headerlink" href="#_21" title="Permanent link">¶</a></h2>
<p>基本的查询流程如下：</p>
<p>解析与翻译 -&gt; 优化 -&gt; 执行</p>
<div align="center">
<img alt="query_steps" src="../images/DB/db24.png" style="zoom :80%;"/>
</div>
<p>衡量查询开销的主要指标有：<strong>磁盘访问时间</strong>、<strong>CPU 延迟</strong>、网络连接等等。一般来说，磁盘访问是主要的性能开销项，其成本也相对容易估算。这一项可以通过以下指标进行量化计算：</p>
<ul>
<li>
<p>寻道(seek)次数 × 平均单次寻道成本</p>
</li>
<li>
<p>读取的磁盘块数 × 平均单块读取成本</p>
</li>
<li>
<p>写入的磁盘块数 × 平均单块写入成本</p>
</li>
</ul>
<p>简化起见，我们本章只使用<strong>块传输次数(number of block transfers)</strong>和<strong>寻道次数(number of seeks)</strong>作为开销的衡量。</p>
<div class="arithmatex">\[
\mathrm{ T_{cost} = b \times t_T + S \times t_s }
\]</div>
<p>上式中，<span class="arithmatex">\(t_T\)</span> 指单块传输时间，<span class="arithmatex">\(t_s\)</span> 指单次寻道时间。这两个指标取决于数据在哪里存储。经验上看，假设一个块的大小为 4KB ：</p>
<ul>
<li>
<p>High end magnetic disk: <span class="arithmatex">\(t_S\)</span> = 4 ms and <span class="arithmatex">\(t_T\)</span> = 0.1 ms</p>
</li>
<li>
<p>SSD: <span class="arithmatex">\(t_S\)</span> = 20-90 <span class="arithmatex">\(\mu s\)</span> and <span class="arithmatex">\(t_T\)</span> = 2-10 <span class="arithmatex">\(\mu s\)</span> for 4KB</p>
</li>
</ul>
<h3 id="selection">选择(Selection)操作<a class="headerlink" href="#selection" title="Permanent link">¶</a></h3>
<p>针对选择操作(<code>select</code>)的算法主要有两类：直接对文件的线性(linear)扫描和使用索引的索引(index)扫描。</p>
<ul>
<li>
<p>线性扫描(A1)</p>
<p>扫描每个文件块，并逐条测试记录，看其是否满足选择的条件。</p>
<ul>
<li>用 <span class="arithmatex">\(b_r\)</span> 描述存储了关系 <span class="arithmatex">\(r\)</span> 记录的块的数量。假设文件连续存储，那么一次线性扫描就需要 </li>
</ul>
<div class="arithmatex">\[
\mathrm{b_r \times t_T + 1 \times t_s}
\]</div>
<p>的时间。</p>
<ul>
<li>
<p>如果选择是基于某个键的，找到目标记录后即可终止查询。此时，<strong>平均来看</strong>块传输的次数就会降到 <span class="arithmatex">\(b_r / 2\)</span>。</p>
</li>
<li>
<p>线性搜索可适用于以下场景：</p>
<ul>
<li>
<p>任意选择条件</p>
</li>
<li>
<p>文件记录无序存储</p>
</li>
<li>
<p>无索引可用</p>
</li>
</ul>
</li>
</ul>
<details class="tip">
<summary>Tip</summary>
<ul>
<li>
<p>二分搜索通常不适用，因为数据物理存储不连续(除非存在索引)</p>
</li>
<li>
<p>二分搜索的寻道次数通常高于索引扫描</p>
</li>
</ul>
</details>
</li>
<li>
<p>索引扫描</p>
<p>注意，在下面的讨论中，<span class="arithmatex">\(h_i\)</span> 总是表示索引的层数。</p>
<ul>
<li>
<p>等值查询</p>
<ul>
<li>
<p>A2(主索引 + 基于主键的等值查询) </p>
<p>获得单条符合条件的记录。</p>
<div class="arithmatex">\[
\mathrm{Cost = (h_i + 1) * (t_T + t_s)}
\]</div>
</li>
<li>
<p>A3(主索引 + 基于非主键的等值查询)</p>
<p>获得多条符合条件的记录。用 <span class="arithmatex">\(b\)</span> 表示存有符合条件的记录的块的数量，</p>
<div class="arithmatex">\[
\mathrm{Cost = h_i * (t_T + t_s) + t_s + t_T \times b}
\]</div>
</li>
<li>
<p>A4(二级索引 + 基于非主键的等值查询)</p>
<p>如果搜索键是候选键，那么可以得到单一的记录。</p>
<div class="arithmatex">\[
\mathrm{Cost = (h_i + 1) * (t_T + t_s)}
\]</div>
<p>如果搜索键不是候选键，那么会得到多条记录。假如一共有 n 条符合要求的记录，这些记录可能分布在不同的块上，因而开销可能会变得很高：</p>
<div class="arithmatex">\[
\mathrm{Cost = (h_i + n) * (t_T + t_s)}
\]</div>
</li>
</ul>
</li>
<li>
<p>比较条件查询</p>
<p>比较条件查询(<span class="arithmatex">\(\sigma_{A \leq V}(r)\)</span> 或者 <span class="arithmatex">\(\sigma_{A \geq V}(r)\)</span>)可以使用前面的线性扫描完成，也可以使用下面的算法：</p>
<ul>
<li>
<p>A5(主索引)，关系已经按照属性 A 排序</p>
<ul>
<li>
<p>对于 <span class="arithmatex">\(\sigma_{A \geq V}(r)\)</span>，我们用索引找到第一个满足 <span class="arithmatex">\(\geq V\)</span> 关系的元组，然后从这里顺序扫描关系即可；</p>
</li>
<li>
<p>对于 <span class="arithmatex">\(\sigma_{A \leq V}(r)\)</span>，我们甚至不需要索引，只需要从关系的开头顺序扫描，直到遇见第一个 <span class="arithmatex">\(&gt; V\)</span> 的元组即可。</p>
</li>
</ul>
</li>
<li>
<p>A6(二级索引)</p>
<ul>
<li>
<p>对于 <span class="arithmatex">\(\sigma_{A \geq V}(r)\)</span>：</p>
<ul>
<li>
<p>通过索引定位到首个 <span class="arithmatex">\(\geq V\)</span> 的索引项</p>
</li>
<li>
<p>顺序扫描后续索引条目，获取指向数据记录的指针</p>
</li>
</ul>
</li>
<li>
<p>对于 <span class="arithmatex">\(\sigma_{A \leq V}(r)\)</span>：</p>
<p>直接扫描索引叶子页，获取指针直到出现首个 <span class="arithmatex">\(&gt; V\)</span> 的条目</p>
</li>
</ul>
</li>
</ul>
<p>上述两种算法：</p>
<ul>
<li>
<p>共同操作：根据指针逐条读取对应数据记录</p>
</li>
<li>
<p>代价特性：每条记录需单独 I/O 操作</p>
</li>
<li>
<p>当满足条件的记录过多时，线性全表扫描可能更高效</p>
<details class="tip">
<summary>推导</summary>
</details>
</li>
</ul>
</li>
<li>
<p>复杂条件查询：多条件合取查询(<span class="arithmatex">\(\sigma_{\theta_1 \land \theta_2 \land ... \land \theta_n}(r)\)</span>)</p>
<ul>
<li>
<p>A7(使用单索引)</p>
</li>
<li>
<p>A8(使用复合索引)</p>
</li>
<li>
<p>A9(使用指针交集 [intersection of identifiers])</p>
</li>
</ul>
</li>
<li>
<p>复杂条件查询：多条件析取查询(<span class="arithmatex">\(\sigma_{\theta_1 \vee \theta_2 \vee ... \vee \theta_n}(r)\)</span>)</p>
<ul>
<li>A10(使用指针并集 [union of identifiers])</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A1-A6 总结：</p>
<div align="center">
<img alt="seek_algorithms" src="../images/DB/db25.png" style="zoom :80%;"/>
</div>
<h3 id="sorting">排序(Sorting)<a class="headerlink" href="#sorting" title="Permanent link">¶</a></h3>
<p>从上面一节，我们知道，在选择操作时我们可能会针对关系构建索引，然后用有顺序的索引去读取关系。</p>
<p>如果 memory 可以容纳目标关系，那么我们就可以用诸如快速排序的技巧。但是，实际情况往往是一个关系的大小不能被 memory 容纳，这个时候我们就需要<strong>外部归并排序(external sort-merge)</strong>。还记不记得 ADS 课程中的讲解？</p>
<p>外部归并排序流程，分治：</p>
<div align="center">
<img alt="merge_sort" src="../images/DB/db26.png" style="zoom :80%;"/>
</div>
<ul>
<li>
<p><strong>Step 1 (初始化)</strong> </p>
<p>每次读入 M 个块到内存中，并在内存中进行排序，记为一个 run <span class="arithmatex">\(R_{i}\)</span>，然后写回磁盘。设完成初始化后得到的 runs 总个数为 <span class="arithmatex">\(N_{0}\)</span>。</p>
</li>
<li>
<p><strong>Step 2 (归并)</strong></p>
<ul>
<li>
<p>如果 <span class="arithmatex">\(N_{0} &lt; M\)</span>：  可以分配 <span class="arithmatex">\(N_{0}\)</span> 个块用于归并，再用一个块作为输出缓冲区。</p>
</li>
<li>
<p>如果 <span class="arithmatex">\(N_{0} \geq M\)</span>：需要进行递归合并，在每一轮中，可合并连续的 <span class="arithmatex">\(M-1\)</span> 个 runs ，并让 runs 的总数量变为 <span class="arithmatex">\(\lceil N/(M-1) \rceil\)</span>，递归直到所有 runs 合并为一个。</p>
</li>
</ul>
</li>
</ul>
<p>结论速通：(M 指放进内存中的块的数量，<span class="arithmatex">\(b_r\)</span> 定义同前)</p>
<ul>
<li>
<p><strong>runs</strong>总数：<span class="arithmatex">\(\lceil b_r / M \rceil\)</span></p>
</li>
<li>
<p>需要的<strong>passes</strong>数：<span class="arithmatex">\(\lceil \log_{M-1}{(b_r / M)} \rceil\)</span></p>
</li>
</ul>
<p>我们知道，一个块在进行排序的时候会产生两次块传输，因为要进入内存、从内存取出。所以，每一个 pass 都会产生 <span class="arithmatex">\(2b_r\)</span> 的块传输。我们不考虑最后一次 pass 的写盘开销，因为一个操作的最终结果可能会被直接传给父操作，不一定会写到盘中。所以，采用归并的<strong>外部排序的块传输总量</strong>是</p>
<div class="arithmatex">\[
b_r (2\lceil \log_{M-1}{(b_r / M)}\rceil - 1) \to O (b_r \log b_r)
\]</div>
<p>每一个 pass 也需要 <span class="arithmatex">\(2b_r\)</span> 次寻道。此外，在生成 runs 的时候，对于每个 run ，磁盘需要一次寻道来读 run ，一次寻道来写 run。因此采用归并的<strong>外部排序的寻道总数</strong>是</p>
<div class="arithmatex">\[
2\lceil b_r / M \rceil + b_r (2\lceil \log_{M-1}{(b_r / M)}\rceil - 1)
\]</div>
<ul>
<li>
<p>存储优化</p>
<ul>
<li>
<p><strong>Motivation</strong> </p>
<p>为了进一步减少寻道成本，将输入和输出缓冲区的大小都设置为 <span class="arithmatex">\(b_{b}\)</span> 个块，这样内存中就只能放下 <span class="arithmatex">\(\lfloor M/b_{b}\rfloor\)</span> 个 runs 了。</p>
</li>
<li>
<p><strong>block-transfer</strong> </p>
<p>共 <span class="arithmatex">\(b_{r}(2\lceil\log_{\lfloor M/b_{b}\rfloor-1}(b_{r}/M)\rceil+1)\)</span> 次。</p>
</li>
<li>
<p><strong>seek</strong> </p>
<p>共 <span class="arithmatex">\(2\lceil b_{r}/M\rceil + \lceil b_{r}/b_{b}\rceil(2\lceil\log_{\lfloor M/b_{b}\rfloor-1}(b_{r}/M)\rceil-1)\)</span> 次。</p>
</li>
</ul>
</li>
</ul>
<h3 id="join">连接(Join)<a class="headerlink" href="#join" title="Permanent link">¶</a></h3>
<p>我们有多种方式来实现连接操作。</p>
<h4 id="nested-loop-join"><strong>Nested-Loop Join</strong><a class="headerlink" href="#nested-loop-join" title="Permanent link">¶</a></h4>
<p>一般来说就是，为了计算 <span class="arithmatex">\(\theta\)</span> - join <span class="arithmatex">\(r \bowtie_{\theta} s\)</span> (此时称 <span class="arithmatex">\(r\)</span> 为<strong>外关系(outer relation)</strong>，<span class="arithmatex">\(s\)</span> 为<strong>内关系(inner relation)</strong>)：</p>
<div align="center">
<img alt="nestedloop_algo" src="../images/DB/db27.png" style="zoom: 90%"/>
</div>
<ul>
<li>
<p>不需要索引，代价是时间开销大，对于每一对元组都需要检查。</p>
</li>
<li>
<p>最坏情况下，内存只能容纳两个关系中的各一个块。此时开销为 <span class="arithmatex">\((n_r + b_r) \times t_s + (n_r \times b_s + b_r) \times t_T\)</span>。</p>
<ul>
<li>
<p>因为每轮都需要重新寻道，外关系遍历需要 <span class="arithmatex">\(b_r \times (t_s + t_T)\)</span></p>
</li>
<li>
<p>对于 <span class="arithmatex">\(n_r\)</span> 个外关系元组中的每一个，都需要对内关系做一次扫描，共花费 <span class="arithmatex">\(n_r \times (t_s + b_s \times t_T)\)</span>。</p>
</li>
</ul>
</li>
<li>
<p>如果内关系可以完全放进内存，开销即可降低为 <span class="arithmatex">\(2 \times t_s + (b_s + b_r) \times t_T\)</span>。</p>
<p>即在一开始先用 <span class="arithmatex">\(t_s + b_s\times t_T\)</span> 的时间将内关系全部读进内存。</p>
</li>
</ul>
<h4 id="block-nested-loop-join"><strong>Block Nested-Loop Join</strong><a class="headerlink" href="#block-nested-loop-join" title="Permanent link">¶</a></h4>
<p>和 Nested-Loop Join 相似，但是从实现上看，内外关系变成了对应关系的 block ，从 block 中再提取元组。</p>
<div align="center">
<img alt="block_nestedloop_algo" src="../images/DB/db28.png" style="zoom: 80%"/>
</div>
<ul>
<li>
<p>最坏情况的开销 </p>
<p><span class="arithmatex">\(2b_{r} \times t_{S} + (b_{r} \times b_{s}) \times t_{T}\)</span></p>
</li>
<li>
<p>内存优化方案</p>
<p>使用内存中的 <span class="arithmatex">\(M-2\)</span> 个块储存外关系，成本可降低为：  <span class="arithmatex">\(2\lceil b_{r}/(M-2)\rceil \times t_{S} + (\lceil b_{r}/(M-2)\rceil \times b_{s} + b_{r}) \times t_{T}\)</span></p>
<ul>
<li>
<p><span class="arithmatex">\(M-2\)</span> 个块用于存储外关系，一个块用于存储内关系， 一个块用于结果输出。</p>
</li>
<li>
<p>具体来说，每轮取出 <span class="arithmatex">\(M-2\)</span> 个块处理，处理开销是 <span class="arithmatex">\(2 \times t_{s} + (b_{s} + b_{r,i}) \times t_{T}\)</span>，其中 <span class="arithmatex">\(\sum b_{r,i} = b_{r}\)</span>。每次都需要重新寻道</p>
</li>
</ul>
</li>
<li>
<p>最好情况</p>
<p><span class="arithmatex">\(2 \times t_{S} + (b_{r} + b_{s}) \times t_{T}\)</span></p>
</li>
<li>
<p>关键结论</p>
<ol>
<li>
<p>扫描策略优化：交替进行向前/向后循环，充分利用缓冲区中的剩余块</p>
</li>
<li>
<p>关系选择原则：若两个关系都不能完全放入内存，将小关系作为外关系的效率更高</p>
</li>
</ol>
</li>
</ul>
<h4 id="indexed-nested-loop-join"><strong>Indexed Nested-Loop Join</strong><a class="headerlink" href="#indexed-nested-loop-join" title="Permanent link">¶</a></h4>
<p>如果</p>
<p><strong>(1)</strong> 连接是等值连接或者自然连接；或者</p>
<p><strong>(2)</strong> 内关系的连接属性上有索引(也可以专门为连接操作而建立)，</p>
<p>我们就可以用 index lookup 替换 file scan。</p>
<ul>
<li>
<p>最坏情况下，缓冲区仅能容纳 <span class="arithmatex">\(r\)</span> 的一个块，并且对于 <span class="arithmatex">\(r\)</span> 中的每个元组都需要在 <span class="arithmatex">\(s\)</span> 上进行一次索引查找。</p>
</li>
<li>
<p>开销为 <span class="arithmatex">\(b_r(t_T + t_s) + n_r \times c\)</span>，其中 <span class="arithmatex">\(c\)</span> 是使用连接条件进行索引查找的代价。</p>
</li>
</ul>
<h4 id="merge-join">Merge Join<a class="headerlink" href="#merge-join" title="Permanent link">¶</a></h4>
<p>若两个关系都已经排序，则可使用类似归并排序的方法计算连接．如果关系未排序则需加上事先排序的代价。</p>
<div class="admonition danger">
<p class="admonition-title">合并连接仅可用于等值连接和自然连接！</p>
</div>
<p>设系统分别为 <span class="arithmatex">\(r\)</span> 和 <span class="arithmatex">\(s\)</span> 分配了 M 个块中的 <span class="arithmatex">\(x_r\)</span> 和 <span class="arithmatex">\(x_s\)</span> 个块(保证 <span class="arithmatex">\(x_r + x_s = M\)</span> )，则开销为</p>
<div class="arithmatex">\[
(\lceil b_r / x_r \rceil + \lceil b_s / x_s \rceil) \times t_s + (b_r + b_s) \times t_T
\]</div>
<h4 id="hash-join">Hash Join<a class="headerlink" href="#hash-join" title="Permanent link">¶</a></h4>
<p>本质上是一种<strong>分治</strong>的思想！哈希连接算法流程大致是：</p>
<ul>
<li>
<p>Partition ：通过哈希函数将关系 <span class="arithmatex">\(r\)</span> 和 <span class="arithmatex">\(s\)</span> 分区并映射到 <span class="arithmatex">\(\{0, 1, …, n_h\}\)</span> 上，并写回磁盘。</p>
</li>
<li>
<p>Build &amp; Probe ：对于 <span class="arithmatex">\(s\)</span> 的每个分区 <span class="arithmatex">\(s_i\)</span>，将其全部载入内存中，并遍历 <span class="arithmatex">\(r_i\)</span> 中的每个块依次载入内存，进行连接。</p>
</li>
</ul>
<p>为了确保 <span class="arithmatex">\(s\)</span> 中的每个分区都能被载入到内存中，我们一般令哈希表容量 <span class="arithmatex">\(n_h \geq \lceil b_s / M \rceil \times f\)</span>，<span class="arithmatex">\(f\)</span> 是 <strong>fudge factor</strong>，一般取 1.2。<span class="arithmatex">\(f\)</span> 的选择动机在于哈希函数决定下的分区不一定是均匀的。<span class="arithmatex">\(r\)</span> 中的分区不需要一开始就载入内存，所以不影响容量的下界。</p>
<p>同时，为了避免进行<strong>递归分区(recursive partitioning)</strong>，我们一般也要求 <span class="arithmatex">\(n_h &lt; M - 1\)</span>。这也是容量的上界。</p>
<p>根据上述界定，我们经过数学运算可知，<span class="arithmatex">\(M &gt; \sqrt{b_s}\)</span>。</p>
<div class="admonition exercise">
<p class="admonition-title">在不进行递归分区的情况下，使用哈希连接最多能处理多大的 relation ？</p>
<p>对于 12M 内存，块大小设置为 4K ．则内存中最多可放下 3K (= 12M / 4K) 个块，可对最大 3K × 3K 个块的关系进行分区并哈希连接，也就是 3K × 3K × 4K = 36G 大小的关系。</p>
</div>
<ul>
<li>
<p>不考虑递归分区，保证没有哈希表溢出：</p>
<ul>
<li>
<p>block-transfer</p>
<ul>
<li>
<p>partition: 关系中的每个块都需要从磁盘中取出，共 <span class="arithmatex">\(b_s + b_r\)</span> 次块传输；还需要按分区进行写回，并且 <span class="arithmatex">\(n_h\)</span> 个分区中的每一个都可能剩一个只装了部分的块，共需 <span class="arithmatex">\(b_s + b_r + 2n_h\)</span> 次块传输。</p>
</li>
<li>
<p>build &amp; probe: 刚才每个写回的块都刚好需要被取出一次，共 <span class="arithmatex">\(b_s + b_r + 2n_h\)</span> 次块传输。</p>
</li>
<li>
<p>成本: <span class="arithmatex">\((3(b_s + b_r) + 4n_h) \times T_T\)</span></p>
</li>
</ul>
</li>
<li>
<p>seek</p>
<ul>
<li>
<p>partition: 假设为输入输出缓冲区各分配了 <span class="arithmatex">\(b_b\)</span> 个块，则划分总共需要 <span class="arithmatex">\(2(\lceil b_s / b_b \rceil + \lceil b_r / b_b \rceil)\)</span> 次寻道。</p>
</li>
<li>
<p>build &amp; probe: 对于每个分区只需要进行一次寻道，总共 <span class="arithmatex">\(2n_h\)</span> 次。</p>
</li>
<li>
<p>成本: <span class="arithmatex">\((2(\lceil b_s / b_b \rceil + \lceil b_r / b_b \rceil) + 2n_h) \times t_S\)</span>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果需要递归分区：那么，每一次递归预计可以减小为原来的 <span class="arithmatex">\(1/(M-1)\)</span> 大小，共需要 <span class="arithmatex">\(d = \lceil \log_{M-1}(b_s) - 1 \rceil\)</span> 次递归。</p>
<ul>
<li>
<p>block-transfer:</p>
<ul>
<li>
<p>partition: <span class="arithmatex">\(2(b_s + b_r) \times d\)</span> 次块传输。</p>
</li>
<li>
<p>build &amp; probe: <span class="arithmatex">\((b_s + b_r)\)</span> 次块传输 (TBD)。</p>
</li>
</ul>
</li>
<li>
<p>seek: <span class="arithmatex">\(2(\lceil b_r / b_b \rceil + \lceil b_s / b_b \rceil) \times d \times t_S\)</span>.</p>
</li>
</ul>
</li>
</ul>
<p>到目前为止：我们已经学习了针对单个操作的算法。</p>
<h4 id="_22">整体表达式树的替代方法<a class="headerlink" href="#_22" title="Permanent link">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">这段我确实有点没看懂，回来补一下</p>
</div>
<p><strong>1. 物化 (Materialization)</strong>：对于一个表达式，如果其输入是(数据库中的)关系或已经计算出的结果，就先计算这个表达式，并将其结果物化(存储)到磁盘上。然后重复这个过程，直到获得最终结果。</p>
<ul>
<li>
<p><strong>物化求值 (Materialized evaluation)</strong>：从(表达式树的)最底层开始，一次执行一个操作。计算出的中间结果会被物化为临时关系，并用于其上一层操作的求值。</p>
<ul>
<li>
<p>物化求值的优点是它总是适用的，但是，将结果写入磁盘再从磁盘读回的<strong>成本</strong>可能相当高。我们之前给出的操作成本公式忽略了将结果写入磁盘的成本，因此：</p>
</li>
<li>
<p><strong>总成本 = 各个独立操作的成本之和 + 将中间结果写入磁盘的成本</strong></p>
</li>
<li>
<p><strong>双缓冲 (Double buffering)</strong>：这是一个优化技术。它为每个操作使用两个输出缓冲区，当一个缓冲区被写满时，系统会将其内容写入磁盘，而计算过程可以同时在另一个缓冲区中进行填充。双缓冲技术使得磁盘写入可以和计算重叠进行，从而减少了总的执行时间。</p>
</li>
</ul>
</li>
</ul>
<p><strong>2. 流水线 (Pipelining)</strong>：一个操作在执行过程中，无需等待其全部完成，就可以将产生的元组(tuples)立即传递给它的父操作。</p>
<ul>
<li>
<p><strong>流水线求值 (Pipelined evaluation)</strong>：同时评估多个操作，将一个操作的结果直接传递给下一个操作。</p>
<ul>
<li>
<p>例如，在之前的表达式树中，不要存储 <span class="arithmatex">\(\sigma_{building="Watson"}(department)\)</span> 的结果。而是应该将元组直接传递给连接(join)操作。同样地，也不要存储连接的结果，而是将元组直接传递给投影(projection)操作。</p>
</li>
<li>
<p>成本比物化(materialization)低得多：因为无需将临时关系存储到磁盘。</p>
</li>
<li>
<p>流水线并非总是可行 —— 例如，像排序(sort)和哈希连接(hash-join)这类操作就不支持。</p>
</li>
</ul>
</li>
</ul>
<p>为使流水线有效，需要使用那些能在接收输入元组的同时就开始生成输出元组的求值算法。流水线可以通过两种方式执行：<strong>需求驱动 (demand driven)</strong> 和 <strong>生产者驱动 (producer driven)</strong>。</p>
<p>在需求驱动的逻辑中：</p>
<ul>
<li>系统会不断向(表达式树的)顶层操作请求下一个元组，每个操作都会向其子操作请求下一个元组。在中间过程中，每个操作都必须保持自身的“状态”(state)以明确自己稍后应该返回什么。</li>
</ul>
<p>在生产者驱动的逻辑中：</p>
<ul>
<li>
<p>操作符会自己给父节点传递自己生成的元组。</p>
</li>
<li>
<p>上下层的操作之间会有缓冲区。子操作会把自己生成的元组先放进缓冲区之中，副操作会根据自身条件筛选其中的元组并剔除不符合要求的那些。如果缓冲区暂满而子操作还没有写入全部的元组，子操作就进入等待，直到有空余空间。</p>
</li>
<li>
<p>系统会调度那些输出缓冲区有空闲空间且能继续处理输入元组的操作。</p>
</li>
</ul>
<details class="success">
<summary>流水线中单个操作的实现</summary>
<p>这里以需求驱动的流水线为例。</p>
<p>每个操作都是以迭代器实现的。迭代器模式将每个关系代数操作封装为统一的接口。迭代器实现了下面的操作：</p>
<ul>
<li>
<p><code>open()</code>：初始化操作，创建操作初始状态(如指针、缓冲区)</p>
<p>例如 文件扫描：重置文件指针到起始位置；合并连接：先排序子关系，初始化游标 等。</p>
</li>
<li>
<p><code>next()</code>：获取下一元组，更新内部状态(如游标位置)</p>
<p>例如 文件扫描：读取当前元组后推进指针；合并连接：继续归并排序过程直至生成下一结果元组 等。</p>
</li>
<li>
<p><code>close()</code>：释放资源，清除所有状态</p>
<p>例如 关闭文件/释放缓冲区等。</p>
</li>
</ul>
</details>
<h2 id="_23">查询优化<a class="headerlink" href="#_23" title="Permanent link">¶</a></h2>
<hr/>
<h2 id="transaction">事务(Transaction)<a class="headerlink" href="#transaction" title="Permanent link">¶</a></h2>
<p><strong>事务(Transaction)</strong>是程序一次执行若干次操作组成的抽象概念，是一个 unit。Transaction 的提出是为了维护数据的完整性。有了事务这一概念，我们还有两个主要的问题：</p>
<ul>
<li>
<p>如何处理并行事务？ --&gt; <a href="#Concurrency_Control">#并发控制(Concurrency Control)</a></p>
</li>
<li>
<p>如何处理例如硬件故障和系统崩溃这样的错误？ --&gt; <a href="#Recovery">#错误恢复(Recovery)</a></p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">事务的状态</p>
<p><div align="center"> <br/>
<img alt="txn_states" src="../images/DB/db23.png" style="zoom :75%;"/>
</div></p>
<ul>
<li>
<p><strong>活跃(Active)</strong> </p>
<p>The initial state; the transaction stays in this state while it is executing</p>
</li>
<li>
<p><strong>部分提交(Partially committed)</strong></p>
<p>After the final statement has been executed.</p>
</li>
<li>
<p><strong>失败(Failed)</strong></p>
<p>After the discovery that normal execution can no longer proceed.</p>
</li>
<li>
<p><strong>中止(Aborted)</strong></p>
<p>after the transaction has been rolled back and the database restored to its state prior to the start of the transaction. Two options after it has been aborted:</p>
<ul>
<li>
<p>Restart the transaction (can be done only if no internal logical error in the transaction)</p>
</li>
<li>
<p>Kill the transaction</p>
</li>
</ul>
</li>
<li>
<p><strong>提交(Committed)</strong></p>
<p>After successful completion.</p>
</li>
</ul>
<p><div align="center"> <br/>
<img alt="stats_" src="../images/DB/db31.png" style="zoom: 80%"/>
</div></p>
</div>
<h3 id="acid">ACID<a class="headerlink" href="#acid" title="Permanent link">¶</a></h3>
<p>事务的实现要求四个特性 ACID ：</p>
<ul>
<li>
<p><strong>A-Atomicity</strong> 原子性</p>
<p>一个事务应该被系统视作一个整体。假如一个事务执行中途发生故障，那么故障点前面属于该事务的操作不能反映到数据库中。也就是说，一个事物要么所有操作(包括 Commit)成功完成，要么所有操作都应该被回滚。</p>
</li>
<li>
<p><strong>C-Consistency</strong> 一致性</p>
<p>总体来说可以解释成：必须保证数据在操作修改前后仍然遵循</p>
<ul>
<li>
<p>显式指定的完整性约束(如主键和外键)</p>
</li>
<li>
<p>隐式完整性约束，例如，所有账户余额的总和减去贷款总额必须等于现金持有量</p>
</li>
</ul>
</li>
<li>
<p><strong>I-Isolation</strong> 隔离性</p>
<p>即使有多个事务正在同时进行，它们彼此之间应该是不知道有其他事务正在进行的(这就是事务锁)。一个事务中途的结果应该对其他事务不可见。</p>
</li>
<li>
<p><strong>D-Durability</strong> 持久性</p>
<p>一个事务声明已经结束后，断电等等的意外不能对已结束的事务的结果数据造成任何影响，也即已提交的修改必须要一直存在。</p>
</li>
</ul>
<p>为了实现隔离性，我们有一个自然的想法，就是让系统每次只能执行一个事务。但是这样效率太慢了，所以我们需要解决<strong>并发控制</strong>的问题。</p>
<h3 id="_24">并发控制<a class="headerlink" href="#_24" title="Permanent link">¶</a></h3>
<p>在允许并行的情况下，实现事务隔离性的机制是<strong>Concurrency control schemes</strong>。我们首先定义，并发事务的各个子操作在 DBMS 内部的具体执行步骤被称为<strong>调度(Schedule)</strong>。</p>
<p>schedule 大致可以分为两种：</p>
<ul>
<li>
<p>串行调度</p>
<p>一个事务执行完再执行另一个。所以， n 个并行事务有 <span class="arithmatex">\(n!\)</span> 种可选择的串行调度。</p>
<p><div align="center"> <br/>
<img alt="serial_schedule" src="../images/DB/db32.png" style="zoom: 80%"/>
</div></p>
<p>串行调度一定可以保持一致性，但是效率较低。</p>
</li>
<li>
<p>并行调度</p>
<p>好的并行调度与串行调度的结果应该相同(S3 与 S1)，意味着上层始终可以按照严格串行来理解和调用数据库，即使其内部并不一定是串行调度。</p>
<p><div align="center"> <br/>
<img alt="concurrent_schedule" src="../images/DB/db33.png" style="zoom: 80%"/>
</div></p>
</li>
</ul>
<h4 id="serializability">可串行性(Serializability)<a class="headerlink" href="#serializability" title="Permanent link">¶</a></h4>
<p>我们说，如果一种并行调度和某种串行调度等价，那么它是<strong>可串行化</strong>的。根据不同的调度等价形式，可引出以下两种概念：</p>
<ol>
<li>
<p>冲突可串行化（ Conflict Serializability ）</p>
</li>
<li>
<p>视图可串行化（ View Serializability ）</p>
</li>
</ol>
<p>在接下来的讨论中，我们只关注读写指令。我们设 <span class="arithmatex">\(I_i\)</span> 和 <span class="arithmatex">\(I_j\)</span> 分别是事务 <span class="arithmatex">\(T_i\)</span> 和 <span class="arithmatex">\(T_j\)</span> 的指令。如果 <span class="arithmatex">\(I_i\)</span> 和 <span class="arithmatex">\(I_j\)</span> 同时对某个对象 Q 进行访问，且至少有一条指令正在向 Q 写入数据，那么这两条指令就是<strong>冲突(conflict)</strong>的。同时读 Q 不构成冲突。</p>
<p>如果一个<u>调度</u> <span class="arithmatex">\(S\)</span> 以通过交换相互不冲突的语句转换为 <span class="arithmatex">\(S'\)</span>，或者说 <span class="arithmatex">\(S\)</span> 与 <span class="arithmatex">\(S'\)</span> 所有相互冲突的指令以相同的顺序排列，称 <span class="arithmatex">\(S\)</span> 和 <span class="arithmatex">\(S'\)</span> 是<strong>冲突等价(conflict equivalent)</strong>的。如果 <span class="arithmatex">\(S\)</span> 冲突等价于一个串行调度序列，称 <span class="arithmatex">\(S\)</span> 是<strong>冲突可串行(conflict serializable)</strong>的。</p>
<div class="admonition warning">
<p class="admonition-title">注意这里“冲突”和“冲突等价/可串行”对应的描述对象是不同的！</p>
</div>
<p>为了直观看到事务的执行顺序，方便我们判断调度是否冲突可串行，我们可以针对某个调度画出<strong>前趋图/优先图(Precedence Graph)</strong>。前趋图是一个有向图，图的顶点是调度中的各事务。如果对于两个事务 <span class="arithmatex">\(T_i\)</span> 和 <span class="arithmatex">\(T_j\)</span>，存在 <span class="arithmatex">\(T_i\)</span> 中的操作 <span class="arithmatex">\(I_i\)</span> 和 <span class="arithmatex">\(T_j\)</span> 中的操作 <span class="arithmatex">\(I_j\)</span>，满足 <u><span class="arithmatex">\(I_i\)</span> 在 <span class="arithmatex">\(I_j\)</span> 前，并且 <span class="arithmatex">\(I_i\)</span> 和 <span class="arithmatex">\(I_j\)</span> 冲突</u>，那么我们从 <span class="arithmatex">\(T_i\)</span> 的顶点引出一条有向边指向 <span class="arithmatex">\(T_j\)</span> 的顶点。我们一般在边上标注冲突指令所要访问的对象。</p>
<p>如果一个调度的前趋图<u>没有环(acyclic)</u>，那么它就是冲突可串行化的。冲突可串行的调度所等价的串行调度的事务顺序可以由前趋图的<strong>拓扑排序(topological sorting)</strong>获得。</p>
<div class="admonition note">
<p class="admonition-title">环检测算法</p>
<ul>
<li>
<p>如果使用邻接矩阵，则其时间复杂度是 <span class="arithmatex">\(O(n^2)\)</span>，这里 <span class="arithmatex">\(n\)</span> 是顶点数量。</p>
</li>
<li>
<p>如果使用 DFS 算法，则时间复杂度可以优化至 <span class="arithmatex">\(O(n+e)\)</span>，这里 <span class="arithmatex">\(e\)</span> 是边的数量。</p>
</li>
</ul>
<p>在事务冲突的语境下，前趋图往往都是<strong>稀疏图</strong>，这个时候采用 DFS 方法效率更高。</p>
</div>
<div align="center">
<img alt="conflict_1" src="../images/DB/db34.png" style="zoom: 80%"/>
</div>
<h4 id="_25">级联调度<a class="headerlink" href="#_25" title="Permanent link">¶</a></h4>
<p>如果并发调度下，某一个事务失败需要回滚会带动其他事务一起回滚，这种情况被称为<strong>级联回滚(cascading rollback)</strong>。如果一个调度序列不会引起任何级联回滚，称它是<strong>非级联调度(cascadeless schedule)</strong>。下图中是一个不是非级联调度的例子，这样的调度被认为是不好的。</p>
<div align="center">
<img alt="cascading_schedule" src="../images/DB/db35.png" style="zoom: 80%"/>
</div>
<p>实现非级联调度的具体要求是，并发事务对同一个数据有读有写时，任意做了写入的事务必须提交后，下一个事务才能从中读。</p>
<p>在一个并发调度序列中，如果一个事务从另外一个事务的结果中读取数据，那么它应该在另外的事务 commit 之后 commit。满足这一条件的调度称为<strong>可恢复的(Recoverable)</strong>。所以，任何非级联调度都是可恢复的调度。</p>
<p>一个数据库系统必须提供一种机制，其应该让所有调度是冲突可串行的，且都是非级联调度。</p>
<h4 id="_26">弱一致性等级<a class="headerlink" href="#_26" title="Permanent link">¶</a></h4>
<p>我们从前面就知道串行调度数据安全性强而性能弱，并行调度反之。实际使用中，这往往不是二选一，而是取折中的问题。下面列出了常见的四种并行化的层次。</p>
<ul>
<li>
<p><strong>Serializable</strong> — default</p>
</li>
<li>
<p><strong>Repeatable read</strong> — only committed records to be read, repeated reads of same record must return same value.  However, a transaction may not be serializable – it may find some records inserted by a transaction but not find others.</p>
</li>
<li>
<p><strong>Read committed</strong> — only committed records can be read, but successive reads of record may return different (but committed) values.</p>
</li>
<li>
<p><strong>Read uncommitted</strong> — even uncommitted records may be read. </p>
</li>
</ul>
<p>不过，以上所有均不允许脏写。</p>
<hr/>
<h2 id="_27">并发控制实现<a id="Concurrency_Control"></a><a class="headerlink" href="#_27" title="Permanent link">¶</a></h2>
<h3 id="lock-based-protocols">Lock-Based Protocols<a class="headerlink" href="#lock-based-protocols" title="Permanent link">¶</a></h3>
<p><strong>锁(lock)</strong>是一种控制并发访问的机制。数据对象一般可以拥有两种锁：</p>
<ul>
<li>
<p>共享锁(Shared - S 锁)。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A。其他事务只能再对 A 加 S 锁，而不能加 X 锁，只能等待直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A ，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p>
</li>
<li>
<p>排他锁(Exclusive - X 锁)。若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A。其他事务不能再对 A 加任何锁，只能等待直到 T 释放 A 上的锁。这保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。</p>
</li>
</ul>
<p>锁相容矩阵如下。该表的含义是两个事务是否可以<strong>同时</strong>对同一个对象加指定的锁。再次提醒，<strong>锁是和事务紧密相关</strong>的。</p>
<div align="center">
<img alt="Lock-compatibility_matrix" src="../images/DB/db36.png"/>
</div>
<h3 id="two-phase-locking-2pl-protocol">Two-Phase Locking (2PL) Protocol<a class="headerlink" href="#two-phase-locking-2pl-protocol" title="Permanent link">¶</a></h3>
<ul>
<li>
<p>第一阶段(Growing Phase)</p>
<p>在这个阶段，事务允许持有锁，不允许其释放锁。如果我们允许锁类型转换，这个阶段事务可以对数据对象施加 S 锁或者 X 锁，或者<strong>升级(upgrade)</strong>S 锁至 X 锁。</p>
</li>
<li>
<p>第二阶段(Shrinking Phase)</p>
<p>在这个阶段，事务允许释放锁，不允许其仍然持有同类型锁。如果我们允许锁类型转换，这个阶段事务可以释放施加的 S 锁或者 X 锁，或者<strong>降级(downgrade)</strong>X 锁至 S 锁。</p>
</li>
</ul>
<p>我们可以采取自动锁获取(Automatic Acquisition of Locks)方法来节省手动工作量：</p>
<ul>
<li>
<p><code>read(D)</code>：自动获取 S 锁（若无其他事务持有 X 锁）。</p>
</li>
<li>
<p><code>write(D)</code>：自动获取 X 锁（必要时等待并升级 S 锁）。</p>
</li>
</ul>
<p>不过我们可以发现，在 2PL 机制下，级联回滚仍然可能发生。为了避免级联回滚，我们可以采用</p>
<ul>
<li>
<p><strong>严格两阶段锁(strict two-phase locking)</strong>：其要求事务持有的 X 锁必须保持到提交/中止，避免级联回滚。</p>
</li>
<li>
<p><strong>强两阶段锁(rigorous two-phase locking)</strong>：所有锁保持到提交/中止，确保事务按提交顺序序列化。</p>
</li>
</ul>
<p>但是，我们可能遇到以下情况：</p>
<div align="center">
<img alt="deadlock_example" src="../images/DB/db38.png"/>
</div>
<p>T3 和 T4 均无法继续执行 ​​。执行 lock-S(B) 会导致 T4 等待 T3 释放 B 的锁；而执行 lock-X(A) 会导致 T3 等待 T4 释放 A 的锁。类似这种情况被称为<strong>死锁(deadlock)</strong>。此时，系统会将 T3 和 T4 进行回滚，并释放锁。2PL 机制并不能完全规避死锁。更坏的是，我们还有可能遇到这种情况：</p>
<blockquote>
<p>一个事务正在等待对某数据对象的 X 锁，然而同时，一系列其他事务已经针对同一个数据对象被授予了 S 锁。这会造成死锁。系统将持续回滚事务，这个可怜的等待 X 锁的事务就会被反复回滚。</p>
</blockquote>
<p>我们称上面这种情况发生了<strong>饥荒(starvation)</strong>。</p>
<p>我们可以通过实现一个 Lock Manager 来解决这个问题。锁管理器需要实现一个 Lock Table ，在内存中用哈希表归类数据，每个数据下辖链表储存当前锁的情况。例如下图中 I7 数据派锁给 T23 ， I23 数据派锁给 T1、T8 而 T2 在等待。</p>
<div align="center">
<img alt="lock_example" src="../images/DB/db37.png" style="zoom: 70%"/>
</div>
<div class="admonition danger">
<p class="admonition-title">幻读</p>
<p>假如我们应用了两阶段锁管理事务，那么删除或插入操作时，要插入或者删除的行都会被加上 X 锁...这看起来没问题，但是...</p>
<blockquote>
<p>一个事务正在扫描全表，此时另一个事务正在向该表中插入行。首先从语义上，这里已经发生了冲突。如果这时只对变动行加锁，非串行调度就会导致——扫描全表的事务并不知道新行的加入，但是读出来的结果却有这个新加的行。(删除也是同理)</p>
</blockquote>
<p>这样就发生了<strong>幻读(phantom phenomenon)</strong>。</p>
</div>
<p>我们有方法可以解决幻读：</p>
<ul>
<li>
<p>关系(relation)级锁：扫描时加 S 锁，插入/删除时加 X 锁。</p>
</li>
<li>
<p>索引锁协议：锁定索引叶子节点（ S/X 锁）避免幻读。</p>
</li>
</ul>
<h3 id="_28">死锁处理<a class="headerlink" href="#_28" title="Permanent link">¶</a></h3>
<p>对死锁的处理可以分为两部分：预防和检测。</p>
<ul>
<li>
<p><strong>预防</strong></p>
<p>系统会给每个事务赋予时间戳。预防存在几种机制：</p>
<ul>
<li>
<p>Wait-Die ：这是一种不抢占(non-preemptive)的策略。老事务可以等待新事务的资源，但新事务若需老事务的资源则直接回滚（不抢占）。</p>
</li>
<li>
<p>Wound-Wait ：这是一种抢占(preemptive)的策略。老事务可以抢占（强制回滚）新事务持有的资源。</p>
</li>
</ul>
<p>这两种机制都可以保证在等待列表里不存在环。</p>
<ul>
<li>Timeout-Based ：一个事务等待超时后回滚该事务。</li>
</ul>
</li>
<li>
<p><strong>检测</strong></p>
<p>我们可以构建一个等待图(wait-for graph)。等待图是一种有向图，其顶点是系统中的所有事务。如果事务 <span class="arithmatex">\(T_i\)</span> 正在等待 <span class="arithmatex">\(T_j\)</span>，我们就从 <span class="arithmatex">\(T_i\)</span> 引出一条有向边指向 <span class="arithmatex">\(T_j\)</span>。死锁检测就可以基于此进行：如果我们的等待图是没有有向环的，那么系统中就不存在死锁。</p>
<p>如果检测到死锁，我们一般选择代价最小的事务作为牺牲者回滚。</p>
</li>
</ul>
<h3 id="tree-based-protocol">Tree-Based Protocol<a class="headerlink" href="#tree-based-protocol" title="Permanent link">¶</a></h3>
<p>树状锁的要求是：</p>
<ul>
<li>
<p>事务只能申请 X 锁，并且对一个数据对象只能申锁一次。</p>
</li>
<li>
<p>事务的第一把锁可以是任何数据对象的；接下来，只有该事务持有了数据对象的父节点的锁，才可以给数据对象加锁。</p>
</li>
<li>
<p>数据对象可以在任何时候解锁。</p>
</li>
</ul>
<div align="center">
<img alt="tree_lock_example" src="../images/DB/db39.png" style="zoom: 70%"/>
</div>
<p>特性：</p>
<ul>
<li>
<p>保证冲突可串行化</p>
</li>
<li>
<p>保证无死锁（优于 2PL ）</p>
</li>
<li>
<p>不保证无联级回滚，但可通过增加限制“排他锁只有到事务结束时才可以释放”来实现</p>
</li>
<li>
<p>相比二阶段锁协议解锁时间自由</p>
</li>
</ul>
<p>问题：</p>
<ul>
<li>有时会给不需要访问的数据项加锁（要求先给父节点加锁），会增加锁开销</li>
</ul>
<h3 id="multiple-granularity-locking">多粒度锁(Multiple Granularity Locking)<a class="headerlink" href="#multiple-granularity-locking" title="Permanent link">¶</a></h3>
<p>多粒度锁（ Multiple Granularity Locking ）的存在是为了<strong>解决数据库系统中并发控制与系统性能之间的核心矛盾</strong>，即如何在保证数据一致性的同时，最大限度地提升并发效率。以下是其存在的关键原因和设计逻辑：</p>
<p><strong>1. 解决“锁开销”与“并发度”的权衡问题</strong></p>
<ul>
<li>
<p><strong>问题背景</strong>：</p>
</li>
<li>
<p><strong>细粒度锁</strong>（如行锁）：并发度高（多个事务可同时修改不同行），但管理开销大（需维护大量锁）。</p>
</li>
<li>
<p><strong>粗粒度锁</strong>（如表锁）：管理简单（只需一个锁），但并发度低（整个表被锁住，阻塞其他事务）。</p>
</li>
<li>
<p><strong>多粒度锁的折中</strong>：</p>
</li>
<li>
<p>允许系统<strong>动态选择锁的粒度</strong>（数据库 → 区域 → 文件 → 记录），根据操作需求平衡开销与并发。</p>
</li>
</ul>
<p><strong>2. 支持复杂操作的灵活性</strong></p>
<ul>
<li>
<p><strong>场景举例</strong>：</p>
</li>
<li>
<p><strong>事务 A</strong>：需要扫描整张表（适合表级 S 锁）。</p>
</li>
<li>
<p><strong>事务 B</strong>：只需修改某一行（适合行级 X 锁）。</p>
</li>
<li>
<p><strong>多粒度锁的作用</strong>：</p>
</li>
<li>
<p>事务 A 加表级 S 锁后，事务 B 仍可对未冲突的行加 X 锁，避免全表阻塞。</p>
</li>
</ul>
<p><strong>3. 避免“隐式资源冲突”</strong></p>
<p>例如幻读问题。</p>
<ul>
<li>
<p><strong>多粒度锁的解决方案</strong>：</p>
</li>
<li>
<p>通过<strong>意向锁（ Intention Lock ）</strong>在高层级（如表）标记低层级（如行）的锁定意图，使扫描事务（加表级 IS 锁）和插入事务（加表级 IX 锁）能提前发现冲突。</p>
</li>
</ul>
<p><strong>4. 意向锁的核心作用</strong></p>
<p>多粒度锁通过引入<strong>意向锁（ IS/IX/SIX ）</strong>实现层级协调：</p>
<ol>
<li>
<p><strong>意向共享锁（ IS ）</strong>：  </p>
</li>
<li>
<p>表示事务将在低层级（如行）加 S 锁。  </p>
</li>
<li>
<p>其他事务可同时获取表级 IS 锁（允许并行读）。</p>
</li>
<li>
<p><strong>意向排他锁（ IX ）</strong>：  </p>
</li>
<li>
<p>表示事务将在低层级加 X 锁。  </p>
</li>
<li>
<p>与表级 S 锁互斥（防止脏读）。</p>
</li>
<li>
<p><strong>共享意向排他锁（ SIX ）</strong>：  </p>
</li>
<li>
<p>表示事务持有表级 S 锁，并将在低层级加 X 锁（如先读全表再改某行）。</p>
</li>
</ol>
<p><strong>兼容性矩阵</strong>：</p>
<table>
<thead>
<tr>
<th>请求 \ 持有</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>IX</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>SIX</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>S</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>X</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p><strong>5. 性能优化示例</strong></p>
<ul>
<li><strong>场景</strong>：  </li>
</ul>
<p>事务 A 需更新 1 万行中的 10 行。</p>
<ul>
<li><strong>无多粒度锁</strong>：  </li>
</ul>
<p>需申请 1 万个行锁，开销极大。</p>
<ul>
<li>
<p><strong>多粒度锁</strong>：  </p>
</li>
<li>
<p>对表加 IX 锁（标记“后续会修改某些行”）。  </p>
</li>
<li>
<p>仅对目标 10 行加 X 锁。  </p>
</li>
</ul>
<p>其他事务仍可读取未冲突的行。</p>
<p><strong>多粒度锁的价值</strong></p>
<ol>
<li>
<p><strong>提升并发</strong>：不同粒度锁组合减少不必要的阻塞。  </p>
</li>
<li>
<p><strong>降低开销</strong>：避免为每个小数据项单独加锁。  </p>
</li>
<li>
<p><strong>防止幻读</strong>：通过高层级意向锁检测潜在冲突。  </p>
</li>
<li>
<p><strong>灵活适配</strong>：根据操作类型（全表扫描 vs 单行修改）选择最优锁策略。  </p>
</li>
</ol>
<p>多粒度锁是数据库系统在<strong>一致性</strong>、<strong>并发度</strong>和<strong>性能</strong>之间找到的最佳平衡点之一。</p>
<h2 id="_29">错误恢复<a id="Recovery"></a><a class="headerlink" href="#_29" title="Permanent link">¶</a></h2>
<p>在数据库系统运行的过程中，我们可能遇到各种各样的故障(failure)：</p>
<ul>
<li>
<p>事务故障（ Transaction Failure ）</p>
<ul>
<li>
<p>逻辑错误（ Logical Errors ）</p>
<p>事务因内部错误条件（如违反业务规则）无法继续执行；如转账金额为负值、除零错误等。</p>
</li>
<li>
<p>系统错误（ System Errors ）</p>
<p>数据库系统必须主动终止活动事务的错误条件；如死锁等。</p>
</li>
</ul>
</li>
<li>
<p>系统崩溃（ System Crash ）</p>
<p>由电源故障、硬件/软件故障导致系统意外终止。</p>
<ul>
<li>
<p><strong>故障停止假设（ Fail-stop Assumption ）</strong>：假定非易失性存储（ Non-volatile Storage ）内容在崩溃时不会被破坏。</p>
<ul>
<li>完整性检查（ Integrity Checks ）：数据库系统通过多重校验防止磁盘数据损坏。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="_30">日志<a class="headerlink" href="#_30" title="Permanent link">¶</a></h3>
<p>为了确保发生故障时仍然能保持原子性，我们可以先保存描述更改的信息，而不是直接更改数据库中的数据。</p>
<div align="center">
<img alt="data_access_example" src="../images/DB/db40.png" style="zoom: 70%"/>
</div>
<p>对每一个事务的每一个 write 做记录：</p>
<ul>
<li>
<p>Transaction 开始时，记录<ti start=""></ti></p>
</li>
<li>
<p>对每一个写操作，记录&lt;事务编号 Ti ，写数据的位置 D ，原值 V0 ，新值 V1&gt;</p>
</li>
<li>
<p>提交时，记录<t1 abort="" commit=""></t1></p>
</li>
</ul>
<p>对于日志的更新时期，我们又有两种方案：</p>
<ul>
<li>
<p><strong>deferred-modification</strong>：</p>
<p>写操作在 commit 以前都是在临时变量中做， commit 后一次写入 buff/disk</p>
</li>
<li>
<p><strong>immediate-modification</strong>：</p>
<p>允许在 commit 之前将值写入 buff/disk。</p>
<p><strong>数据项写入前，其更新日志记录必须已持久化；数据库页刷出到磁盘前，其关联的所有日志记录必须已输出。</strong></p>
</li>
</ul>
<p>本章中我们只讨论 immediate 的做法。</p>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy", "search.share", "search.suggest", "search.highlight"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
<script src="../assets/javascripts/bundle.13a4f30d.min.js"></script>
<script src="../javascripts/mathjax.js"></script>
<script src="https://cdn.tonycrane.cc/utils/katex.min.js"></script>
<script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
</body>
</html>